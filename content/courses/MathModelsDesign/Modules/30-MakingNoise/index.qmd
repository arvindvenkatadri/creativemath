---
title: <iconify-icon icon="fluent-mdl2:hour-glass" width="1.2em" height="1.2em"></iconify-icon> Making Noise Predictably
subtitle: "Meeting Ken Perlin"
abstract: "Can you make the same random noise again?"
date: 2024-Nov-07
date-modified: "`r Sys.Date()`"
order: 30
categories:
- Noise Generation
- Perlin Noise
- Simplex Noise
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(blogdown)
library(tidyverse)
library(ggformula)
library(mosaicCalc) # Analytic Calculus
library(ambient) # Noise generation in R
library(plot3D) # 3D plots for explanation
library(caracas)
library(downloadthis)
library(knitr)
library(kableExtra)
## Markdown boiler plate stuff!!
# ![An Elephant](elephant.png){#fig-elephant}
# This is illustrated well by @fig-elephant.
# 
# ### Figure Panel Divs
#     ::: {#fig-elephants layout-ncol=2}
#     ![Surus](surus.png){#fig-surus}
#     ![Hanno](hanno.png){#fig-hanno}
#      Famous Elephants
#     :::
#     Adding download buttons
#     data that has been read in
#     {{< downloadthis ../../../../materials/Data/housing_train.csv dname="house_prices" label="Download the House Prices Dataset" icon="database-fill-down" type="info" >}}
#    existing file
#    {{< downloadthis Orange/grouped-summaries.ows dname="grouped_summaries" label="Download the Orange Workflow" icon="database-fill-down" type="info" >}} 

```

```{r}
#| label: Extra Pedagogical Packages
#| echo: false
#| message: false

library(checkdown)
library(epoxy)
library(grateful)
library(MKdescr)
library(shinylive) # To create a Shiny app in a Quarto HTML doc
# Will not work if webr is also used in the SAME Quarto doc!
library(sysfonts)
library(gfonts)
library(kableExtra)
# library(conflicted)
# conflicted::conflicts_prefer(dplyr::filter, dplyr::count, dplyr::last, dplyr::glimpse, base::max)
library(downloadthis)
#devtools::install_github("mccarthy-m-g/embedr")
library(embedr) # Embed multimedia in HTML files
```

```{r}
#| label: Plot Sizing and theming
#| echo: false
#| message: false
#| results: hide

# https://stackoverflow.com/questions/74491138/ggplot-custom-fonts-not-working-in-quarto

# Chunk options
knitr::opts_chunk$set(
 fig.width = 7,
 fig.asp = 0.618, # Golden Ratio
 #out.width = "80%",
 fig.align = "center"
)
### Ggplot Theme
### https://rpubs.com/mclaire19/ggplot2-custom-themes

theme_custom <- function(){ 
    font <- "Roboto Condensed"   #assign font family up front
    
    theme_classic(base_size = 14) %+replace%    #replace elements we want to change
    
    theme(
      panel.grid.minor = element_blank(),    #strip minor gridlines
      text = element_text(family = font),
      #text elements
      plot.title = element_text(             #title
                   family = font,            #set font family
                   #size = 20,               #set font size
                   face = 'bold',            #bold typeface
                   hjust = 0,                #left align
                   #vjust = 2                #raise slightly
                   margin=margin(0,0,10,0)
),               
      
      plot.subtitle = element_text(          #subtitle
                   family = font,            #font family
                   #size = 14,                #font size
                   hjust = 0,
                   margin=margin(2,0,5,0)
),               
      
      plot.caption = element_text(           #caption
                   family = font,            #font family
                   size = 8,                 #font size
                   hjust = 1),               #right align
      
      axis.title = element_text(             #axis titles
                   family = font,            #font family
                   size = 10                 #font size
),
      
      axis.text = element_text(              #axis text
                   family = font,            #axis family
                   size = 8)               #font size
    )
}

# Set graph theme
theme_set(new = theme_custom())
#
```

## {{< iconify fe beginner >}} What graphs will we see today?

We will understand the basics of *procedural noise generation*: generating random noise-like numbers that allow us to model and create very realistic-looking textures, such as wood, terrain, mountains, and clouds. 


## {{< iconify icons8 idea >}} Inspiration

::: {#fig-births layout-ncol="2"}


Perlin Noise based Textures
:::


## {{< iconify mdi food-processor-outline >}} What is Perlin Noise?

Ok, this is going to be a long explanation!!!

#### A. Inner Product Computation

Let us start by dividing up 2D space ( for now!!) into square-shaped cells. At each vertex we randomly place a [**unit gradient vector**]{.purple} labelled $r_{i}$ that points in a random direction. See the figure below:

<center>
<iframe width="780px" height="600px" src="https://editor.p5js.org/arvindv/full/6CosUsBQt">
</iframe>
</center>

We wish to calculate the Perlin Noise amount at [any point of interest]{.green} inside the cell. 

- We draw [difference vectors to the point]{.red} from each of the 4 vertices. 
- We compute the vector **dot product** with each of the $r_{i}$ and the above difference vectors. ( 4 dot products )
- These are shown in the text print at the side of the figure.

::: callout-note
### Dot Products are Scalars with Polarity
Note how the 4 dot products change as you move the mouse/touchpad. This changes the 4 gradient vectors and hence the scalar dot products change in amplitude **and** polarity. 

In a typical Perlin Noise implementation, the gradient vectors are **fixed** after an initial setup. So each gradient vector generates a range of dot-product values as the point of interest moves within the cell. 

:::

#### B. Interpolation of Dot Product values

With the 4 scalar dot products, we are now ready to compute the Perlin Noise value at the point of interest. There are several ways of doing this:

- Simply take the average
- Take a **weighted** average, with fixed weights.
- Use a wieghting/interpolating function: The closer a point of interest is to one or other of the cell vertices, the higher is the contribution of the corresponding dot-product. 

The third approach is the one embedded within (all?) Perlin Noise implementations. The interpolating function is:
$$
f(t) = 6t^5-15t^4+10t^3
$$
and looks like this:

```{r}
#| label: interpolating-function
#| echo: false

# Set graph theme
theme_set(new = theme_custom())
#

## Unit Square Surface
gf_polygon(c(0,0.25, 0.25,0) ~ c(0,0.25, 0.75,1), 
           fill = "grey90") %>% 
## Interpolating function from V(0,0)
  gf_fun(6*(1-x)^5 - 15 * (1-x)^4 + 10* (1-x)^3 ~ x, 
       xlim = c(0, 1), linetype = "dashed") %>% 
## Vertices
  gf_point(c(0,0.25, 0.25,0) ~ c(0,0.25, 0.75,1), size = 3,, 
       title = "Interpolating Function", 
       subtitle = "Used from each vertex of a unit square area",
       ylab = "Dot Product Weighting\n from Vertex(0,0)") %>% 
  
## Gradient Vectors
  gf_segment(0 + 0.125 ~ 0 + 0.2,  
             arrow = arrow(ends = "last", angle = 10),
             colour = ~"Gradient1",linewidth = 1) %>% 
  gf_segment(0 + 0.125 ~ 1 + 0.75, 
             arrow = arrow(ends = "last", angle = 10),
             colour = ~"Gradient2", linewidth = 1) %>% 
  ## Tilted Y-axis
  gf_segment(0 + 0.35 ~ 0 + 0.35, 
             arrow = arrow(ends = "last", angle = 10), 
             colour = "black", linewidth = 1) %>%
  
## Difference Vectors to POI
  gf_segment(0 + 0.125 ~ 0 + 0.35,  
             arrow = arrow(ends = "last", angle = 10),
             colour = "grey40",linewidth = 1) %>% 
  gf_segment(0 + 0.125 ~ 1 + 0.35,  
             arrow = arrow(ends = "last", angle = 10),
             colour = "grey40",linewidth = 1) %>% 
## Point of Interest
  gf_point(0.125 ~ 0.35, size = 4, colour = ~ "Point of Interest") %>% 
  ## X-axis
    gf_segment(0 + 0 ~ 0 + 1.25, 
               arrow = arrow(ends = "last", angle = 10), 
               colour = "black", linewidth = 1) %>%
  ## Labels
  gf_refine(annotate(geom = "text", label = "Vertex(0,0)", 
                     x = 0.1, y = -0.05,size = 3)) %>% 
  gf_refine(annotate(geom = "text", 
                     label = "Vertex(1,0)", 
                     x = 1.05, y = -0.05, size = 3)) %>%
  gf_refine(annotate(geom = "text", 
                     label = "Vertex(0,1)", 
                     x = 0.125, y = 0.25, size = 3)) %>% 
  gf_refine(annotate(geom = "text", 
                     label = "Vertex(1,1)", 
                     x = 0.875, y = 0.25, size = 3)) %>% 
  gf_refine(annotate(geom = "text", 
                     label = "Point of Interest", 
                     x = 0.375, y = 0.175, size = 2)) %>% 
  #gf_refine(coord_fixed()) %>% 
  gf_theme(theme = theme(axis.line = element_blank(),
                         axis.ticks = element_blank(),
                          panel.grid = element_blank(),
                          legend.title = element_blank(),
                           axis.title.x = element_blank(),
                           axis.text.x = element_blank()))

```

```{r}
#| label: 3D-plot-interpolation-function
#| echo: false
#| warning: false
#library(plot3D)
x = c(0:25) / 25
y = c(0:25) / 25
##
my_data <- expand_grid(x, y) %>%
  mutate(
    r = sqrt(x ^ 2 + y ^ 2),
    rscaled = r / max(r),
    z = 6 * (1 - rscaled) ^ 5 - 15 * (1 - rscaled) ^ 4 + 10 * (1 -
                                                                 rscaled) ^ 3
  )
my_points <- tibble(
  x = c(0, 0, 1, 1, 0.6),
  y = c(0, 1, 0, 1, 0.2),
  z = c(0, 0, 0, 0, 0)
)
my_gradient <- tibble(x = c(0, 0.5),
                      y = c(0, -0.2),
                      z = c(0, 0))
my_vector <- tibble(x = c(0, 0.6),
                    y = c(0, 0.2),
                    z = c(0, 0))
scene = list(camera = list(eye = list(
  x = 0.75, y = -1.5, z = 1.25
)))
my_data %>%
  plot_ly(x = ~ x, y = ~ y, z = ~ z) %>%
  add_mesh(opacity = 0.5) %>%
  
  add_markers(
    data = my_points,
    x = ~ x,
    y = ~ y,
    z = ~ z,
    color = c("Vertex", "Vertex", "Vertex", "Vertex", "PoI")
  ) %>%
  
  add_lines(
    data = my_gradient,
    name = "Gradient Vector",
    showlegend = T,
    line = list(
      color = 'purple',
      width = 10,
      symbol = 'arrow-right'
    )
  ) %>%
  
  add_lines(
    data = my_vector,
    name = "Point Vector",
    mode = "lines",
    line = list(
      symbol = "arrow",
      arrow_style = 'arrow-right',
      size = 10,
      color = 'red',
      width = 10,
      angleref = "previous"
    )
  ) %>%
  layout(title = "Interpolation from Vertex (0,0)", scene = scene)

```

::: callout-note
### Interpolation Function $f(t)$ has smooth ends
Both $\frac{df(t)}{dt}$ and $\frac{d^2f(t)}{dt}$ are continuous at the ends of the range of the function (t = 0 and t = 1).

```{r}
#| echo: false
#| eval: false
library(mosaicCalc)
mosaicCalc::D(6*t^5 - 15*t^4 + 10*t^3 ~ t) ->fdash
fdash
D(fdash(t) ~ t)
```

$$
\begin{array}{lcl}f'(t) & = & \ \frac{d}{dt}[6*t^5 - 15*t^4 + 10*t^3]\\
& = & 30 * (t^4 - 2 * t^3 + t^2)\\
& = & 0  \ \text{@ t = 0 and t = 1}
\end{array}
$$

$$
\begin{array}{lcl}f''(t) & = & \ \frac{d^2}{dt^2}[6*t^5 - 15*t^4 + 10*t^3]\\
& = &60 * (2 * t^3 - 3 * t^2 + t)\\
& = & 0  \ \text{@ t = 0 and t = 1}
\end{array}
$$
This ensures that there are not sudden changes in the noise function near about the vertices. 

:::

#### D. Fractal Overlay and Combining

Now that we have one grid full of a *layer* of noise generated by weighted dot-products, we can appreciate one more thing: we can overlay the space with **several layers** of such noise values. Why would this be a good idea?

This multiple layer overlay creates a very natural-looking **fractal-ness** in the resulting noise function. Most natural looking shapes like landscapes, mountains, vegetables, flames...all have this *self-similar* structure where when one zooms in, the magnified function looks pretty much like the un-zoomed version!!

So how we create and merge overlays? We create several more-closely-spaced grids, and generate noise in the same way. These layers of noise-s are scaled by a factor (Usually $\frac{1}{2^n}$), where $n$ is the "order"of the layer. Each new finely-spaced layer generates similar-looking noise functions, which are combined with smaller and smaller weights to achieve that final polished fractal look of Perlin Noise. 

We will explore this fractality with code.

```{r}
#| echo: false
#library(ambient)
```



## {{< iconify ph chart-scatter-bold >}} Creating Textures and Waveforms with Perlin Noise

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### Using p5.js


### Using R


:::



## {{< iconify mingcute thought-line >}} Wait, But Why?


## {{< iconify ooui references-ltr >}} References

1. <https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise.html>

1. <https://www.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-noise/a/perlin-noise>

1. <https://adrianb.io/2014/08/09/perlinnoise.html>

1. <https://www.arendpeter.com/Perlin_Noise.html>

1. <https://mzucker.github.io/html/perlin-noise-math-faq.html>


1. <https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/>



::: {#refs style="font-size: 60%;"}
###### {{< iconify lucide package-check >}} R Package Citations

```{r}
#| echo: false
#scan_packages()
cite_packages(
  output = "table",
  out.dir = ".",
  out.format = "html",
  pkgs = c("ambient", "mosaicCalc", "plot3D")
) %>%
  knitr::kable(format = "simple")

```

:::

