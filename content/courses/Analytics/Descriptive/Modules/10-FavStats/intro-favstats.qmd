---
title: "\U0001F4CA Descriptive Statistics "
subtitle: "Mirror, mirror on the wall..."
author: "Arvind V."
date: 15/Oct/2023
date-modified: "`r Sys.Date()`"
abstract: "Who is the Fairest of them All?"
order: 20
image: preview.png
image-alt: Image by rawpixel.com
categories:
- Qual Variables
- Quant Variables
- Mean
- Median
- Standard Deviation
- Quartiles
bibliography: 
  - references.bib
  - grateful-refs.bib
citation: true
editor: 
  markdown: 
    wrap: 72
webr:
  packages: ['readr', 'dplyr','mosaic', 'skimr', 'ggformula', 'palmerpenguins']
---

## {{< iconify mdi web-check >}} Using web-R
This tutorial uses `web-r` that allows you to run all code within your browser, on all devices. Most code chunks herein are formatted in a tabbed structure ( like in an old-fashioned library) with duplicated code. The tabs in front have regular R code that will work when copy-pasted in your RStudio session. The tab "behind" has the `web-R` code that can work directly in your browser, and can be modified as well. The R code is also there to make sure you have original code to go back to, when you have made several modifications to the code on the `web-r` tabs and need to compare your code with the original!

#### Keyboard Shortcuts

- Run selected code using either:
  - macOS: <kbd>⌘</kbd> + <kbd>↩/Return</kbd>
  - Windows/Linux: <kbd>Ctrl</kbd> + <kbd>↩/Enter</kbd>
- Run the entire code by clicking the "Run code" button or pressing <kbd>Shift</kbd>+<kbd>↩</kbd>. 


## {{< iconify noto-v1 package >}} Setting up R Packages

```{r}
#| label: setup
#| include: true
#| message: false
#| warning: false

library(tidyverse)
library(mosaic)
library(palmerpenguins) # dataset "penguins"
library(skimr)
library(kableExtra)


```

```{r}
#| label: Themes and Extra Packages
#| echo: false
#| message: false
ggplot2::theme_set(new = theme_classic(base_size = 14, base_family = "roboto"))
library(checkdown)
library(epoxy)
library(explore) # fake data generation
library(grateful)

```

## {{< iconify fxemoji japanesesymbolforbeginner >}} How do we Grasp Data?

We spoke of Experiments and Data Gathering in the first module [Nature of Data](/content/courses/Analytics/Descriptive/Modules/05-NatureData/nature-data.qmd#sec-where-data). This helped us to **obtain** data.

As we discussed in that same Module, for us to grasp the significance of
the data, we need to **describe** it; the actual data is usually too
vast for us to comprehend in its entirety. Anything more than a handful
of observations in a dataset is enough for us to require other ways of
grasping it.

The first thing we need to do, therefore, is to reduce it to a few
salient numbers that allow us to summarize the data.

::: callout-important
## Reduction is Addition

Such a **reduction** may seem paradoxical but is one of the important
tenets of statistics: reduction, while taking away information, ends up
*adding* to insight.

Steven @stigler2016 is the author of the book "*The Seven Pillars of
Statistical Wisdom*". One of the *Big Ideas in Statistics* from that
book is: **Aggregation**

> The first pillar I will call Aggregation, although it could just as
> well be given the nineteenth-century name, "The Combination of
> Observations," or even reduced to the simplest example, taking a mean.
> Those simple names are misleading, in that I refer to an idea that is
> now old but was truly revolutionary in an earlier day---and it still
> is so today, whenever it reaches into a new area of application. How
> is it revolutionary? By stipulating that, given a number of
> observations, you can actually gain information by **throwing
> information away**! In taking a simple arithmetic mean, we discard the
> individuality of the measures, subsuming them to one summary.
:::

Let us get some inspiration from Brad Pitt, from the movie [Moneyball](https://www.netflix.com/in/title/70201437), which is about applying Data Analytics to the game of baseball.

{{< video https://youtu.be/PlKDQqKh03Y >}}

## {{< iconify grommet-icons test >}} Case Study-1

We will first use a dataset `mpg` that is available in R as part of one
of the R packages that we have loaded with the `library()` command.

### {{< iconify file-icons influxdata >}} Examine the Data

It is usually a good idea to make crisp business-like tables, for the
data itself, and the *schema* as revealed by one of the outputs of the
three methods to be presented below. There are many methods to do this; 
one of the simplest and effective ones is to use the `kable` set of commands from the `knitr` and `kableExtra` packages:

```{r}
#| label: kable-for-data-1
mpg %>% 
  head(10) %>%
  kbl(
    # add Human Readable column names
    col.names = c("Manufacturer", "Model", "Engine\nDisplacement", 
                    "Model\n Year", "Cylinders", "Transmission",
                    "Drivetrain", "City\n Mileage", "Highway\n Mileage",
                    "Fuel", "Class\nOf\nVehicle"), 
    caption = "MPG Dataset") %>%
  kable_styling(bootstrap_options = c("striped", "hover", 
                                      "condensed", "responsive"),
                full_width = F, position = "center")

```


Next we will look at a few *favourite statistics* or
"favstats" that we can derive from data. R is full of packages that can
provide very evocative and effective summaries of data. We will first
start with the `dplyr` package from the tidyverse, the `skimr` package,
then the `mosaic` package. We will look at the summary outputs from
these and learn how to interpret them.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

#### Using dpylr::glimpse()

The `dplyr` package offers a convenient command called `glimpse`:

```{r}
#| label: glimpse-1
glimpse(mpg)

```

::: callout-note
#### Descriptive Stat Summary from `dplyr::glimpse()`

Very crisp output, giving us the size of the dataset (234 X 11) and the
nature of the variable columns, along with their first few entries. The
`chr` variables are usually *Categorical/Qualitative*, the `int` or
`dbl` (double precision) are usually *Numerical/Quantitative*. But be
careful! *Verify that this is as per your intent, interpret the variables and modify their encoding as needed.*
:::

#### Using skimr::skim()

Let us look at `mpg`using `skimr::skim()`.

From the output of `?skimr`:

> The format of the results are a single wide data frame combining the
> results, with some additional attributes and two metadata columns:

-   `skim_variable`: name of the original variable
-   `skim_type`: class of the variable

We can use `skim(dataset)` directly as shown below:

```{r}
skimr::skim(mpg) # explicitly stating package name

```

Taken together, we have the following:

::: callout-note
### Descriptive Stat Summary from `skimr::skim()`

-   A *Data Summary*: it lists the dimensions of the `mpg` dataset: 234
    rows and 11 columns. 6 columns are character formatted, the
    remaining 5 are numeric. The dataset is not "grouped" (more on this
    later).

-   The second part of the output shows a table with the `character`
    variables which are therefore `factor` variables with `levels`.

-   The third part shows a table listing the names and summary stats for
    the `numerical` variables. We have `mean`, `sd`, all the quantiles
    (p0, p25, p50(median), p75 and p100 percentiles) and **a neat little
    histogram** for each. From the histogram we can see that `year` is
    two-valued, `cyl` is three-valued, and `cty` and `hwy` are
    continuous... Again check that this is as you intend them to be. We
    may need to modify the encoding if needed.
:::

#### Using mosaic::inspect()

We get very similar output from `mosaic::inspect()`:

```{r}
#| label: inspect-mpg

inspect(mpg)

```

::: callout-note
### Descriptive Stat Summary from `mosaic::inspect()`

We see that the output of `mosaic::inspect()` is organized as follows:

-   There are two dataframes/tables in the output, one describing the
    *Qualitative Variables* and the other describing the *Quantitative
    Variables*.
-   In the table describing the Qual variables, we have:
    -   `name`: Name of the variable in the (parent) dataset. i.e Column
        Names
    -   `class`: format of that column
    -   `levels`: All these variables are factors, with levels shown
        here. Some for example, `manufacturer` has 15 levels, and there
        are 234 rows

`inspect` also conveniently shows how much data is **missing** and in
which variables. This is a very important consideration in the use of
the data for analytics purposes.
:::

We can save and see the outputs separately:

```{r mpg-inspect-2, eval=FALSE}

mpg_describe <- inspect(mpg)
mpg_describe$categorical
mpg_describe$quantitative

```

:::

## {{< iconify grommet-icons test >}} Case Study-2

Instead of taking a "built-in" dataset , i.e. one that is part of an R
package that we can load with `library()`, let us try the above process
with a data set that we obtain from the internet. We will use this
superb repository of datasets created by Vincent Arel-Bundock:
<https://vincentarelbundock.github.io/Rdatasets/articles/data.html>

Let us choose a modest-sized dataset, say this dataset on
`Doctor Visits`, which is available online
<https://vincentarelbundock.github.io/Rdatasets/csv/AER/DoctorVisits.csv> and
read it into R.

::: callout-important
### Reading external data into R

The `read_csv()` command from R package `readr` allows us to read both locally saved data on our hard disk, or data available in a shared
folder online.
Avoid using the `read.csv()` from base R, though it will show up in your code auto-complete set of options! 
:::

```{r}
#| message: true
# From Vincent Arel-Bundock's dataset website
# https://vincentarelbundock.github.io/Rdatasets
# 
# read_csv can read data directly from the net
# 
docVisits <- read_csv("https://vincentarelbundock.github.io/Rdatasets/csv/AER/DoctorVisits.csv")

```
So, a data frame containing 5,190 observations on 12 variables.

::: callout-note
### How about a locally stored CSV file?
We can also use a locally downloaded and stored CSV file. Assuming the file is stored in a subfolder called `data` inside your `R project` folder, we can proceed as follows:

```{r}
#| echo: fenced
#| eval: false
docVisits <- read_csv("data/DoctorVisits.csv")

```

:::
Let us quickly report the data itself, as in a real report. Note that we can use the features of the `kableExtra` package to dress up this table too!!

```{r}
#| label: kable-for-data02
docVisits %>%
  head(10) %>%
  kbl(caption = "Doctor Visits Dataset",
      # Add Human Readable Names if desired
      # col.names(..names that you may want..)
      ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover",
                          "condensed", "responsive"),
    full_width = F, position = "center")

```


### {{< iconify file-icons influxdata >}} Examine the Data

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

#### Using dplyr::glimpse()

```{r}
#| label: glimpse-2
glimpse(docVisits)
```

::: callout-note
#### Descriptive Stat Summary from `dplyr::glimpse()`

Very crisp output, giving us the size of the dataset (5190 X 13) and the
nature of the variable columns, along with their first few entries.
There are several Quantitative variables: `visits`, `age`, `income`, `illness`, `reduced` and `health`; the rest seem to be Qualitative variables. 

Always document your data with variable descriptions when you share it, a **data dictionary**!

:::


| Variable   | Description                                                                                                     |
|------------|------------------------------------------------------------|
| visits     | Number of doctor visits in past 2 weeks.                                                                        |
| gender     | Factor indicating gender.                                                                                       |
| age        | Age in years divided by 100.                                                                                    |
| income     | Annual income in tens of thousands of dollars.                                                                  |
| illness    | Number of illnesses in past 2 weeks.                                                                            |
| reduced    | Number of days of reduced activity in past 2 weeks due to illness or injury.                                    |
| health     | General health questionnaire score using Goldberg's method.                                                     |
| private    | Factor. Does the individual have private health docVisits?                                                      |
| freepoor   | Factor. Does the individual have free government health docVisits due to low income?                            |
| freerepat  | Factor. Does the individual have free government health docVisits due to old age, disability or veteran status? |
| nchronic   | Factor. Is there a chronic condition not limiting activity?                                                     |
| lchronic   | Factor. Is there a chronic condition limiting activity?                                                         |

#### Using skimr::skim()

```{r}
#| label: skim-2
skim(docVisits) %>% kbl()
```

::: callout-note
### Descriptive Stat Summary from `skimr::skim()`

-   A *Data Summary*: it lists the dimensions of the `docVisits`
    dataset: 5190 rows and 13 columns. 6 columns are character
    formatted, the remaining 7 are numeric. The dataset is not "grouped"
    (more on this later).

-   The second part of the output shows a table with the `character`
    variables which are therefore `factor` variables with `levels`.

-   The third part shows a table listing the names and summary stats for
    the `numerical` variables. We have `mean`, `sd`, all the quantiles
    (p0, p25, p50(median), p75 and p100 percentiles) and **a neat little
    histogram** for each.
    
-   Can we consider the `health` Goldberg score a Qualitative variable, to be understood as "ranks" between a minimum and maximum? It is just possible...
:::

#### Using mosaic::inspect()

```{r}
#| label: inspect-2
inspect(docVisits)
```

::: callout-note
### Descriptive Stat Summary from `mosaic::inspect()`

We see that the output of `mosaic::inspect()` is organized very
similarly to the output from `skim`. Is there any missing data? Both
`skim` and `mosaic` report on the data completion for each variable in
the dataset.
:::

:::

## {{< iconify mdi-light group >}} {{< iconify mdi counting-5 >}} Groups and Counts of Qualitative Variables

What is the most important dialogue uttered in the movie ["Sholay"](https://youtu.be/chi9hsfYcDE)?

Recall our discussion in [Types of Data Variables](.../../../05-NatureData/nature-data.qmd#sec-data-types). We 
have looked at *means, limits, and percentiles* of **Quantitative**
variables. Another good idea to examine datasets is to look at *counts, proportions,and frequencies* with respect to **Qualitative** variables. 

We typically do this with the `dplyr` package from the `tidyverse`.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### diamonds dataset

```{r}
#| label: diamonds-counts-and-tables

diamonds %>% count(cut)
diamonds %>% count(color)
diamonds %>% count(clarity)

### All combinations of cut, color, clarity
diamonds %>% 
  count(across(where(is.ordered)))

```

::: callout-note
### Business Insights from Groups and Counts (`diamonds`)

We see that the groups for each level of `cut`, `color`, and `clarity`
are not the same size: for instance the group with the "ideal" cut is
largest at 21K observations, and "fair" has only 1.6K observations.

Group counts based on `color` are also not balanced, and nor are those
for `clarity`. Counting all combinations of these three `factors` also
shows imbalanced counts.

These aspects may need to be factored into downstream modelling or
machine learning tasks. (Usually by stratification wrt levels of the
Qualitative variables)

The levels are not too many, so tables work, and so would bar charts,
which we will examine next. If there are too many levels in any factor,
tables are a better option. Bar charts can still be plotted, but it may
be preferable to `lump` smaller categories/levels together. (Using the
`forcats` package)
:::

### docVisits dataset

```{r}
#| label: docVisits-counts-and-tables-1
## Counting by the obvious factor variables
docVisits %>% count(gender)
docVisits %>% count(private)
docVisits %>% count(freepoor)
docVisits %>% count(freerepat)
docVisits %>% count(lchronic)
docVisits %>% count(nchronic)

```

```{r}
#| label: docVisits-counts-and-tables-2
# Now for all Combinations...
# Maybe too much to digest...
docVisits %>% count(across(where(is.character)))
# Shall we try counting by some variables that might be factors?
# Even if they are labeled as <dbl>?
# 
docVisits %>% count(illness)
docVisits %>% count(health)

```

::: callout-note
### Business Insights from Groups and Counts (`docVisits`)

- Most of the counts are roughly balanced across the *levels* of the factors; however, `freepoor` and `lchronic` show unbalanced counts...

- The factors are too numerous for a combination count table to very useful..

- Counting by `illness` and `health` does show that these two columns have a limited set of integer entries across over 5000 rows!! So these can be thought of as factors if needed in the analysis.

:::

:::

## {{< iconify vaadin group >}} {{< iconify carbon summary-kpi >}} Groups and Summaries of Quantitative Variables

We saw that we could obtain **numerical summary stats** such as `means, medians, quartiles, maximum/minimum` of **entire** Quantitative variables, i.e the complete column. However, we often need identical numerical summary stats of parts of a Quantitative variable. Why?

Note that we have *Qualitative* variables as well in a typical dataset. These Qual variables help us to **group** the entire dataset based on their combinations of **levels**. We can now think of *summarizing Quant variables* within each such group. 

Let us work through these ideas for both our familiar datasets.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### diamonds dataset

```{r}
#| label: mean-price-over-Qual-vars
diamonds %>% 
  group_by(clarity) %>% 
  summarize(average_price = mean(price), count = n())

diamonds %>% 
  group_by(clarity, color) %>% 
  summarize(average_price = mean(price), count = n())

```
::: callout-note
### Business Insights from Grouped Quant Summaries (`diamonds`)
We have a good range of mean_prices over `clarity` and `cut`. The number of groups are large enough (>> 7!) to warrant a chart, which we will make in our next module on [Distributions](.../../../20-Distributions/intro-dist.qmd).

:::

### docvisits dataset

```{r}
#| label: summaries-over-levels-of-Qual

docVisits %>%
  group_by(gender) %>% 
  summarize(average_visits = mean(visits), count = n())

docVisits %>%
  group_by(gender) %>% 
  summarize(average_visits = mean(visits), count = n())

docVisits %>% group_by(freepoor,nchronic) %>% 
  summarise(mean_income = mean(income),
            average_visits = mean(visits),
            count = n())
```
::: callout-note
### Business Insights from Grouped Quant Summaries (`docVisits`)

Clearly the people who are `freepoor` ( On Govt Insurance) AND with a chronic condition are those who have lower average income and a higher average number of visits to the doctor...but there are relatively few of them (n = 55) in this dataset. 

:::

:::


## {{< fa folder-open >}} More on dplyr

The `dplyr` package is capable of doing much more than just `count`, `group_by` and `summarize`. We will encounter this package many times more as we build our intuition about data visualization. A full tutorial on `dplyr` is linked to the icon below: 

| <a href="../../../../../labs/r-labs/tidy/dplyr.qmd"><iconify-icon icon="carbon:data-blob"></iconify-icon> `dplyr` Tutorial</a> |
|--------------------------------------------------------------|

## {{< iconify mdi table-star >}} Reporting Tables for Data and the Data Schema

::: callout-important
### Data and the Data Schema are Different!!

Note that all the three methods (`dplyr::glimpse()`, `skimr::skim()`, and `mosaic::inspect()`)  report the **schema** of the original
dataframe. The schema are also **formatted as data frames**! However
they do not "contain" the original data! Do not confuse between the data
and it's reported schema!
:::

As stated earlier, it is usually a good idea to make crisp business-like tables, for the data itself, and of the *schema* as revealed by one of the outputs of the
three methods presented above. There are many methods to do this; one of
the simplest and effective ones is to use the `kable` set of commands
from the `knitr` package that we have installed already:

```{r}
#| label: kable-for-data-2
mpg %>% 
  head(10) %>%
  kbl(col.names = c("Manufacturer", "Model", "Engine\nDisplacement", 
                    "Model\n Year", "Cylinders", "Transmission",
                    "Drivetrain", "City\n Mileage", "Highway\n Mileage",
                    "Fuel", "Class\nOf\nVehicle"), 
      longtable = FALSE, centering = TRUE,
      caption = "MPG Dataset") %>%
    kable_styling(bootstrap_options = c("striped", "hover", 
                                        "condensed", "responsive"),
                  full_width = F, position = "center")

```

And for the schema from `skim()`, with some extra bells and whistles on the table:

```{r}

skim(mpg) %>%
  kbl(align = "c", caption = "Skim Output for mpg Dataset") %>%
kable_paper(full_width = F)
  
```

See <https://haozhu233.github.io/kableExtra/> for more options on formatting the table with kableExtra. 


## {{< iconify material-symbols person >}} A Quick Quiz

::: callout-warning
It is always a good idea to look for variables in data that may be
incorrectly formatted. For instance, a variable marked as *numerical*
may have the values 1-2-3-4 which represent `options`, `sizes`, or say
`months`. in which case it would have to be interpreted as a `factor`.
:::

Let us take a small test with the `mpg` dataset:

-   What is the number of *qualitative/categorical* variables in the
    `mpg` data?
    `r checkdown::check_question(answer = 6, right = "correct", wrong = "not correct", placeholder = "enter a number")`
    <br>
-   How many manufacturers are named in this dataset?
    `r checkdown::check_question(answer = 15, right = "correct", wrong = "not correct", placeholder = "enter a number")`
    <br>
-   How many levels does the variable `drv` have?
    `r checkdown::check_question(answer = 3, right = "correct", wrong = "not correct", placeholder = "enter a number")`
    <br>
-   How many *quantitative/numerical* variables **shown** in the `mpg`
    data?
    `r checkdown::check_question(answer = 5, right = "correct", wrong = "not correct", placeholder = "enter a number")`
    <br>
-   But the
    variable`r checkdown::check_question(answer = "cyl", options = c("hwy", "cty", "cyl", "displ"), type = "select", right = "correct", wrong = "not correct", placeholder = "select a variable name")`
    is actually a **qualitative variable**.


## {{< iconify fluent-mdl2 decision-solid >}} Conclusion

The three methods given here give us a very comprehensive look into the
**structure** of the dataset. 

Use the `kable` set of commands to make a smart-looking of the data and the outputs of any of the three methods. 

Make these part of your *Workflow*.

## {{< iconify ooui references-rtl >}} References

::: {#refs style="font-size: 60%;"}
###### {{< iconify lucide package-check >}} R Package Citations

```{r}
#| echo: false
#scan_packages()
cite_packages(
  output = "table",
  out.dir = ".",
  out.format = "html",
  pkgs = c("mosaic", "palmerpenguins", "skimr")
) %>%
  knitr::kable(format = "simple")

```
:::
