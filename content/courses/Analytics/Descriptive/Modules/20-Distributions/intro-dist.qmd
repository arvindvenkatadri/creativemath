---
title: "\U0001F4CA Distributions, Densities, Bar Plots, and Boxplots"
subtitle: "How many of this and that?"
author: "Arvind V."
date: 15/Nov/2022
date-modified: "`r Sys.Date()`"
abstract: "Quant and Qual Variable Graphs and their Siblings"
order: 20
image: preview.jpg
image-alt: Image by rawpixel.com
df-print: paged
categories:
- Qual Variables
- Quant Variables
- Bar Charts
- Column Charts
- Histograms
- Density Plots
- Box Plots
- Violin Plots
bibliography: 
  - references.bib
  - grateful-refs.bib
citation: true
#suppress-bibliography: true
# editor: 
#   markdown: 
#     wrap: 72
webr:
  packages: ['readr', 'tidyr', 'dplyr','mosaic', 'skimr', 'ggformula','ggridges', 'palmerpenguins']

---

## {{< fa folder-open >}} Slides and Tutorials

|                                                                                                 |                                                                                                    |                                                                                        |
|------------------------|------------------------|------------------------|
| <a href="./files/distributions.qmd"><i class="fa-brands fa-r-project"></i> R (Static Viz)</a>   | <a href="./files/distributions.rda"> <i class="fa-solid fa-person-rays"></i> Radiant Tutorial</a>  | <a href="./files/data/qdd-data.zip"> <i class="fa-solid fa-database"></i> Datasets</a> |

## {{< iconify mdi web-check >}} Using web-R
This tutorial uses `web-r` that allows you to run all code within your browser, on all devices. Most code chunks herein are formatted in a tabbed structure ( like in an old-fashioned library) with duplicated code. The tabs in front have regular R code that will work when copy-pasted in your RStudio session. The tab "behind" has the `web-R` code that can work directly in your browser, and can be modified as well. The R code is also there to make sure you have original code to go back to, when you have made several modifications to the code on the `web-r` tabs and need to compare your code with the original!

#### Keyboard Shortcuts

- Run selected code using either:
  - macOS: <kbd>⌘</kbd> + <kbd>↩/Return</kbd>
  - Windows/Linux: <kbd>Ctrl</kbd> + <kbd>↩/Enter</kbd>
- Run the entire code by clicking the "Run code" button or pressing <kbd>Shift</kbd>+<kbd>↩</kbd>. 

## {{< iconify noto-v1 package >}} Setting up R Packages

```{r}
#| label: setup
#| include: true
#| message: false
#| warning: false
options(paged.print = TRUE)
library(tidyverse)
library(mosaic)
library(ggformula)

#install.packages("remotes")
#library(remotes)
#remotes::install_github("wilkelab/ggridges")
library(ggridges)
library(skimr)

library(palmerpenguins) # Our new favourite dataset

```


```{r}
#| label: Extra Pedagogical Packages
#| echo: false
#| message: false

library(checkdown)
library(epoxy)
library(TeachHist)
library(TeachingDemos)
library(visualize) # Plot Densities, Histograms and Probabilities as areas under the curve
library(grateful)
library(MKdescr)
library(shinylive) # To create a Shiny app in a Quarto HTML doc
# Will not work if webr is also used in the SAME Quarto doc!
library(sysfonts)
library(gfonts)
library(kableExtra)
# library(conflicted)
# conflicted::conflicts_prefer(dplyr::filter, dplyr::count, dplyr::last, dplyr::glimpse, base::max)

```

```{r}
#| label: Plot Sizing and theming
#| echo: false
#| message: false
#| results: hide

# https://stackoverflow.com/questions/74491138/ggplot-custom-fonts-not-working-in-quarto

# Chunk options
knitr::opts_chunk$set(
 fig.width = 7,
 fig.asp = 0.618, # Golden Ratio
 #out.width = "80%",
 fig.align = "center"
)
### Ggplot Theme
### https://rpubs.com/mclaire19/ggplot2-custom-themes

theme_custom <- function(){ 
    font <- "Roboto Condensed"   #assign font family up front
    
    theme_classic(base_size = 14) %+replace%    #replace elements we want to change
    
    theme(
      panel.grid.minor = element_blank(),    #strip minor gridlines
      text = element_text(family = font),
      #text elements
      plot.title = element_text(             #title
                   family = font,            #set font family
                   #size = 20,               #set font size
                   face = 'bold',            #bold typeface
                   hjust = 0,                #left align
                   #vjust = 2                #raise slightly
                   margin=margin(0,0,10,0)
),               
      
      plot.subtitle = element_text(          #subtitle
                   family = font,            #font family
                   #size = 14,                #font size
                   hjust = 0,
                   margin=margin(2,0,5,0)
),               
      
      plot.caption = element_text(           #caption
                   family = font,            #font family
                   size = 8,                 #font size
                   hjust = 1),               #right align
      
      axis.title = element_text(             #axis titles
                   family = font,            #font family
                   size = 10                 #font size
),
      
      axis.text = element_text(              #axis text
                   family = font,            #axis family
                   size = 8)               #font size
    )
}

# Set graph theme
theme_set(new = theme_custom())
#
```


```{r}
#| label: Do-not-include
#| eval: false
#| include: false

# webr::install("tidyverse")
# webr::install("mosaic")
# webr::install("palmerpenguins")
# webr::install("ggformula")
# webr::install("ggridges")
# webr::install("skimr")
# library(tidyverse)
# library(mosaic)
# library(palmerpenguins)
# library(ggformula)
# library(ggridges)
# library(skimr)
# 
# download.file(
#   url = 'https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/race.csv', 
# destfile = 'race_df.csv')
# 
# download.file(
#   url = "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/ultra_rankings.csv", 
#   destfile = "rank_df.csv")
# 
# # Read the data
# race_df <- read_csv("race_df.csv")
# rank_df <- read_csv("rank_df.csv")

```

## {{< iconify fxemoji japanesesymbolforbeginner >}} What graphs will we see today?

| Variable #1 | Variable #2 | Chart Names |                    Chart Shape    | 
|:-------------:|:--------------:|:------------------:|:--------------------:|:------:|
|    Quant    |    None     |  Histogram, Box Plot, Bar Chart  | {{< iconify mdi-light chart-histogram size=4x >}} {{< iconify carbon box-plot size=4x >}} {{< iconify ion bar-chart size=4x >}}|

Some of the very basic and commonly used plots for data are:

-   Bar and Column Charts
-   Histograms and Frequency Distributions
-   Box Plots
-   Ridge Plots ( Quant + Qual variables)

## {{< iconify tabler variable >}} What kind of Data Variables will we choose?

::: column-page-inset-right
```{r}
#| message: false
#| echo: false
#| warning: false
read_csv("../../../../../materials/Data/pronouns.csv") %>% 
  filter(No == "1") %>% 
  kbl() %>%
  kable_paper("hover", full_width = T)
  
```
:::


## {{< iconify icons8 idea >}} Inspiration

::: {#fig-golf-drive-evolution layout-ncol=2}

![](../../../../../materials/images/Golf-Drive-Distance-1983.png)

![](../../../../../materials/images/Golf-Drive-distance-2017.png)
Golf Drive Distance over the years

:::

What do we see here? In about two-and-a-half decades, golf drive distances have increased, *on the average*, by 35 yards. 
The maximum distance has also gone up by 30 yards, and the minimum is now at 250 yards, which was close to average in 1983! What was a decent average in 1983 is just the bare minimum in 2017!!

Is it the dimples that the golf balls have? But these have been around a long time...or is it the clubs, and the swing technique invented by more recent players? 

Now, let us listen to the late great Hans Rosling from the [Gapminder
Project](https://www.gapminder.org), which aims at telling stories of
the world with data, to remove systemic biases about poverty, income and
gender related issues.

{{< video https://vimeo.com/127511255 >}}

### {{< iconify ic round-addchart >}} Graphing Packages in R

There are several Data Visualization packages, even systems, within R.

-   Base R supports graph making out of the box;

-   The most well known is `ggplot` <https://ggplot2-book.org/> which
    uses Leland Wilkinson's concept of a "Grammar of Graphics";

-   There is the `lattice` package
    <https://lattice.r-forge.r-project.org/> which uses the "Trellis
    Graphics" concept framework for data visualization developed
    by R. A. Becker, W. S. Cleveland, et al.;

-   And the `grid` package
    <https://bookdown.org/rdpeng/RProgDA/the-grid-package.html> that
    allows extremely fine control of `shapes` plotted on the graph.

Each system has its benefits and learning complexities. We will look at
plots created using the simpler and intuitive `ggformula` system that
uses the popular`ggplot` framework, but provides a simplified interface
that is easy to recall and apply. While our first option will be to use
`ggformula`, we will, where appropriate state `ggplot` code too for
comparison.

A quick reminder on how `mosaic` and `ggformula` work in a very similar
fashion:

::: callout-tip
### `mosaic` and `ggformula` command template

Note the standard method for all commands from the `mosaic` and
`ggformula` packages: `goal( y ~ x | z, data = _____)`

With `ggformula`, one can create any graph/chart using:
`gf_***(y ~ x | z, data = _____)`

In practice, we often use: `dataframe %>%  gf_***(y ~ x | z)` which has
cool benefits such as "autocompletion" of variable names, as we shall
see. The "\*\*\*" indicates what kind of graph you desire: histogram,
bar, scatter, density; the "\_\_\_" is the name of your dataset that you
want to plot with.
:::

::: callout-tip
### `ggplot` command template

The `ggplot`2 template is used to identify the dataframe, identify the x
and y axis, and define visualized layers:

`ggplot(data = ---, mapping = aes(x = ---, y = ---)) + geom_----()`

Note: ---- is meant to imply text you supply. e.g. function names, data
frame names, variable names.

It is helpful to see the argument mapping, above. In practice, rather
than typing the formal arguments, code is typically shorthanded to this:

`dataframe %>%  ggplot(aes(xvar, yvar)) + geom_----()`
:::

## {{< iconify icon-park-outline chart-histogram >}} Bar Charts and Histograms

**Bar Charts** show counts of observations with respect to a **Qualitative** variable. For instance, a shop inventory with shirt-sizes. Each *bar* has a height proportional to the *count* per shirt-size, in this example. 

Although **Histograms** may look similar to **Bar Charts**, the two are
different. First, histograms show *continuous Quant data*. By contrast,
bar charts show *categorical data*, such as shirt-sizes, or apples, bananas, carrots, etc.

**Histograms** are best to show the distribution of raw **Quantitative data**, by displaying the number of values that fall within defined
ranges, often called *buckets* or *bins*. We use a **Quant** variable on
the `x-axis` and the histogram shows us how frequently different values
occur for that variable by showing *counts/frequencies* on the y-axis.
The x-axis is typically broken up into "buckets" or ranges for the
x-variable, And usually you can adjust the bucket ranges to explore
frequency patterns. For example, you can shift histogram buckets from
0-1, 1-2, 2-3, etc. to 0-2, 2-4, etc. Histograms do not usually show spaces between buckets because the buckets represent contiguous ranges, while bar charts show spaces to separate each (unconnected) *category/level* within a Qual variable.

To complicate matters: Having said all that, the histogram is really a bar chart in disguise! You probably suspect that *the "bucketing" of the Quant variable is tantamount to creating a Qual variable*! Each bucket is a *level* in this fictitious bucketed *Quant* variable. 

## {{< iconify grommet-icons test >}} Case Study-1: `diamonds` dataset

We will first look at at a dataset that is directly available in R, the
`diamonds` dataset.

### {{< iconify file-icons influxdata >}} Examine the Data

As per our Workflow, we will look at the data using all the three
methods we have seen.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R
```{r}
#| label: using-glimpse
glimpse(diamonds)

```

```{r}
#| label: skim-diamonds
skim(diamonds)

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: using-glimpse-webr
glimpse(diamonds)

```

```{webr-r}
#| label: skim-diamonds-webr
skim(diamonds)

```


:::


::: callout-note
### Business Insights on Examining the `diamonds` dataset

-   This is a large dataset (54K rows).
-   There are several Qualitative variables: `cut`, `color` and
    `clarity`. These have 5, 7, and 8 levels respectively. The fact that
    the `class` for these is `ordered` suggests that these are factors 
    and that the levels have a sequence/order.
-   `carat`, `price`, `x`, `y`, `z`, `depth` and `table` are
    Quantitative variables.
-   There are no missing values for any variable, all are complete with
    54K entries.
:::

### {{< iconify ph chart-bar >}} Plotting Histograms

Let's plot some histograms.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### Using ggformula

```{r}
#| label: histograms-ggformula
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##
gf_histogram(~ price, data = diamonds) %>%
  gf_labs(title = "Plot A: Diamond Prices",caption = "ggformula") 

###
diamonds %>% 
  gf_histogram(~ price, 
               fill = ~ cut, 
               alpha = 0.3) %>%
  gf_labs(title = "Plot B: Prices by Cut",
          caption = "ggformula")

###
diamonds %>% 
  gf_histogram(~ price, 
               fill = ~ cut) %>%
  gf_facet_wrap(~ cut) %>%
  gf_labs(title = "Plot C: Prices by Filled and Facetted by Cut",
          caption = "ggformula") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45, hjust = 1)))

###
diamonds %>% 
  gf_histogram(~ price,
                          fill = ~ cut, 
                          color = "black") %>% 
  gf_facet_wrap(~ cut, scales = "free_y", nrow = 2) %>%
  gf_labs(title = "Plot D: Prices Filled and Facetted by Cut", 
          subtitle = "Free y-scale",
          caption = "ggformula") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45, hjust = 1)))

```

### Using ggplot

```{r}
#| label: histograms-ggplot
#| layout-ncol: 2
#| message: false

## Set graph theme
theme_set(new = theme_custom())
##

ggplot(data = diamonds) + 
  geom_histogram(aes(x = price)) +
  labs(title = "Plot A: Diamond Prices",
       caption = "ggplot")

###
diamonds %>% ggplot() + 
  geom_histogram(aes(x = price, 
                     fill = cut), 
                     alpha = 0.3) + 
  labs(title = "Plot B: Prices by Cut",
       caption = "ggplot")

###
diamonds  %>% ggplot() + 
  geom_histogram(aes(price, fill = cut)) +
  facet_wrap(facets = vars(cut)) + 
  labs(title = "Plot C: Prices by Filled and Facetted by Cut",
       caption = "ggplot") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

###
diamonds  %>% ggplot() + 
  geom_histogram(aes(price, fill = cut), color = "black") +
  facet_wrap(facets = vars(cut), scales = "free_y") +
  labs(title = "Plot D: Prices by Filled and Facetted by Cut",
       subtitle = "Free y-scale",
       caption = "ggplot") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: histograms-ggformula-webr
#| layout-ncol: 2

gf_histogram(~ price, data = diamonds) %>%
  gf_labs(title = "Plot A: Diamond Prices",
          caption = "ggformula")

```

```{webr-r}

diamonds %>% 
  gf_histogram(~ price, 
               fill = ~ cut, 
               alpha = 0.3) %>%
  gf_labs(title = "Plot B: Prices by Cut",
          caption = "ggformula")

```

```{webr-r}
diamonds %>% 
  gf_histogram(~ price,
               fill = ~ cut) %>%
  gf_facet_wrap(~ cut) %>%
  gf_labs(title = "Plot C: Prices by Filled and Facetted by Cut",
          caption = "ggformula") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45, hjust = 1)))

```

```{webr-r}
diamonds %>% 
  gf_histogram(~ price,
               fill = ~ cut, 
               color = "black") %>% 
  gf_facet_wrap(~ cut, scales = "free_y", nrow = 2) %>%
  gf_labs(title = "Plot D: Prices Filled and Facetted by Cut", 
          subtitle = "Free y-scale",
          caption = "ggformula") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45, hjust = 1)))

```

```{webr-r}
#| label: histograms-ggplot-webr
#| layout-ncol: 2
#| message: false

# Set graph theme
# ggplot2::theme_set(new = theme_classic(base_size = 14, 
#                                        base_family = "sans"))

ggplot(data = diamonds) + 
  geom_histogram(aes(x = price)) +
  labs(title = "Plot A: Diamond Prices",caption = "ggplot")

```

```{webr-r}
diamonds %>% 
  ggplot() + 
  geom_histogram(aes(x = price, 
                     fill = cut), 
                     alpha = 0.3) + 
  labs(title = "Plot B: Prices by Cut",caption = "ggplot")

```

```{webr-r}
diamonds  %>% 
  ggplot() + 
  geom_histogram(aes(price, fill = cut)) +
  facet_wrap(facets = vars(cut)) + 
  labs(title = "Plot C: Prices by Filled and Facetted by Cut",
       caption = "ggplot") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{webr-r}
diamonds  %>% 
  ggplot() + 
  geom_histogram(aes(price, fill = cut), color = "black") +
  facet_wrap(facets = vars(cut), scales = "free_y") +
  labs(title = "Plot D: Prices by Filled and Facetted by Cut",
       subtitle = "Free y-scale",
       caption = "ggplot") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

:::

::: callout-note
### Business Insights from `diamond` Histograms

-   The price distribution is heavily skewed to the right. There are
    many diamonds that have low prices and relatively few diamonds that
    are very expensive. This `long-tailed` nature of the histogram holds
    true **regardless** of the `cut` of the diamond.
-   See the x-axis range for each plot in Plot D! Price ranges are the
    same regardless of cut !! Very surprising! So `cut` is perhaps not
    the only thing that determines price...
-   Facetting the plot into *small multiples* helps look at patterns
    better: overlapping histograms are hard to decipher. Adding `color`
    defines the bars in the histogram very well.
:::

::: callout-important
### A Hypothesis

The surprise insight above should lead you to make a Hypothesis! You
should decide whether you want to investigate this question further,
making more graphs, as we will see. Here, we are making a **Hypothesis**
that more than just `cut` determines the `price` of a diamond.
:::

### An Interactive App for Histograms

Type in your Console:

```{r}
#| echo: fenced
#| eval: false
install.packages("shiny")
library(shiny)
runExample("01_hello")      # an interactive histogram

```



### {{< iconify ic baseline-bar-chart >}} Plotting Barcharts

Let's plot some bar graphs: recall that for bar charts, we need to
choose **Qual** variables to count with!

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### Using ggformula

```{r}
#| label: bar-charts-ggformula
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

gf_bar(~ cut, data = diamonds) %>%
  gf_labs(title = "Plot A: Diamonds Counts of different Cuts")


###
diamonds %>% 
  gf_bar( ~ cut, 
          fill = ~ cut) %>%
  gf_labs(title = "Plot B: Diamonds Counts filled by Cut")


###
diamonds %>% 
  gf_bar( ~ cut, 
          fill = ~ clarity, 
          position = "stack",
          alpha = 0.3) %>%
  gf_labs(title = "Plot C: Diamonds Counts by Cut filled by Clarity",
          subtitle = "Stacked Bar Chart")

###
diamonds %>% 
  gf_bar( ~ cut, 
          fill = ~ clarity, 
          position = "dodge",
          color = "black") %>%
  gf_refine(scale_fill_viridis_d(option = "turbo")) %>% # inferno, magma, cividis...etc
  gf_labs(title = "Plot D: Diamonds Counts by Cut filled by Clarity",
          subtitle = "Dodged Bar Chart",
          caption = "Turbo Palette from Viridis set")
```

```{r}

## Set graph theme
theme_set(new = theme_custom())
##

diamonds %>% gf_bar( ~ cut, 
                     fill = ~ clarity, 
                     position = "dodge", 
                     colour = "black") %>%
  gf_facet_wrap(vars(color),scales = "free_y") %>%
  gf_refine(scale_fill_viridis_d(option = "turbo")) %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1))) %>%
  gf_labs(title = "Plot E: Diamonds Counts by Cut filled by Clarity",
          subtitle = "Dodged Bar Chart Facetted by Color",
          caption = "Turbo Palette from Viridis set")
```

### Using ggplot

```{r}
#| label: bar-charts-ggplot
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

ggplot(diamonds)  + 
  geom_bar(aes(cut)) + 
  labs(title = "Plot A: Diamonds Counts of different Cuts")


###
diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = cut) ) + 
  labs(title = "Plot B: Diamonds Counts filled by Cut")


###
diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = clarity), 
               position = "stack",
               alpha = 0.3) + 
  labs(title = "Plot C: Diamonds Counts by Cut filled by Clarity",
       subtitle = "Stacked Bar Chart")

###
diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = clarity), 
               position = "dodge",
               color = "black") + 
  scale_fill_viridis_d(option = "turbo") +  # inferno, magma, cividis...etc
  labs(title = "Plot D: Diamonds Counts by Cut filled by Clarity",
       subtitle = "Dodged Bar Chart",
       caption = "Turbo Palette from Viridis set")

```

```{r}

## Set graph theme
theme_set(new = theme_custom())
##

diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = clarity), 
               position = "dodge", 
               colour = "black") +
  facet_wrap(vars(color), scales = "free_y") + 
  scale_fill_viridis_d(option = "turbo") +
  theme(axis.text.x = element_text(angle = 45,hjust = 1)) + 
  labs(title = "Plot E: Diamonds Counts by Cut filled by Clarity",
       subtitle = "Dodged Bar Chart Facetted by Color",
       caption = "Turbo Palette from Viridis set")

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: bar-charts-ggformula-webr
#| layout-ncol: 2

gf_bar(~ cut, data = diamonds) %>%
  gf_labs(title = "Plot A: Diamonds Counts of different Cuts")

```

```{webr-r}
diamonds %>% 
  gf_bar( ~ cut, 
          fill = ~ cut) %>%
  gf_labs(title = "Plot B: Diamonds Counts filled by Cut")

```

```{webr-r}
diamonds %>% 
  gf_bar( ~ cut, 
          fill = ~ clarity, 
          position = "stack",
          alpha = 0.3) %>%
  gf_labs(title = "Plot C: Diamonds Counts by Cut filled by Clarity",
          subtitle = "Stacked Bar Chart")

```

```{webr-r}
diamonds %>% 
  gf_bar( ~ cut, 
          fill = ~ clarity, 
          position = "dodge",
          color = "black") %>%
  gf_refine(scale_fill_viridis_d(option = "turbo")) %>% # inferno, magma, cividis...etc
  gf_labs(title = "Plot D: Diamonds Counts by Cut filled by Clarity",
          subtitle = "Dodged Bar Chart",
          caption = "Turbo Palette from Viridis set")
```

```{webr-r}

diamonds %>% gf_bar( ~ cut, 
                     fill = ~ clarity, 
                     position = "dodge", 
                     colour = "black") %>%
  gf_facet_wrap(vars(color), scales = "free_y") %>%
  gf_refine(scale_fill_viridis_d(option = "turbo")) %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45, hjust = 1))) %>%
  gf_labs(title = "Plot E: Diamonds Counts by Cut filled by Clarity",
          subtitle = "Dodged Bar Chart Facetted by Color",
          caption = "Turbo Palette from Viridis set")
```


```{webr-r}
#| label: bar-charts-ggplot-webr
#| layout-ncol: 2

ggplot(diamonds)  + 
  geom_bar(aes(cut)) + 
  labs(title = "Plot A: Diamonds Counts of different Cuts")

```

```{webr-r}
diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = cut) ) + 
  labs(title = "Plot B: Diamonds Counts filled by Cut")

```

```{webr-r}
diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = clarity), 
               position = "stack",
               alpha = 0.3) + 
  labs(title = "Plot C: Diamonds Counts by Cut filled by Clarity",
       subtitle = "Stacked Bar Chart")

```

```{webr-r}
diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = clarity), 
               position = "dodge",
               color = "black") + 
  scale_fill_viridis_d(option = "turbo") +  # inferno, magma, cividis...etc
  labs(title = "Plot D: Diamonds Counts by Cut filled by Clarity",
       subtitle = "Dodged Bar Chart",
       caption = "Turbo Palette from Viridis set")
```

```{webr-r}

diamonds %>% 
  ggplot() + 
  geom_bar(aes(cut, fill = clarity), 
               position = "dodge", 
               colour = "black") +
  facet_wrap(vars(color), scales = "free_y") + 
  scale_fill_viridis_d(option = "turbo") +
  theme(axis.text.x = element_text(angle = 45,hjust = 1)) + 
  labs(title = "Plot E: Diamonds Counts by Cut filled by Clarity",
       subtitle = "Dodged Bar Chart Facetted by Color",
       caption = "Turbo Palette from Viridis set")
```

:::

::: callout-note
### Business Insights from `diamond` Bar Charts

As seen before the counts for different values of `cut` are not the
same:

-   the dataset is not balanced.
-   From Plot D, the counts per level of `cut` increase steadily, with
    `Ideal` cut dominating.
-   And the counts at different values of `clarity` within each `cut`
    are also not equal; the levels `VS1, VS2, VVS1, VVS2` tend to be
    higher.
-   From Plot E, we have `cut`, `clarity` facetted by `color`. The
    overall counts are higher for the `Ideal` `cut` across all `color`s.
-   Among the `color`s, the color `J` seems to have the lowest counts,
    judging from the y-axis limits.
:::


::: callout-note
### `gf_bar`vs `gf_col` (and `geom_bar` vs `geom_col`)

These two geometries in `ggformula` and `ggplot` do very similar things: give us a bar plot. There is **one significant difference** however: `gf_bar/geom_bar` **performs counting internally**, whereas `gf_col/geom_col` need the data to be counted beforehand. `gf_counts()` is another name for `gf_bar()`.
See the code below:

```{r}
#| layout-ncol: 2
#| results: hold

## Set graph theme
theme_set(new = theme_custom())
##

diamonds %>% 
  gf_bar(~ cut) %>% # performs counts based on `cut` (Qual variable)
                # default y-axis labelling is "count"
                
  gf_labs(title = "Bar Plot Counts internally")
###

diamonds %>% 
  # count gives a default variable called `n`
  # We rename it to "counts". 
  # Note the quotation marks in the naming ceremony below
  count(cut, name = "How_Many") %>% 
  
  # gf_col needs counted data
  # we use the (re)named variable counts vs cut
  gf_col(How_Many ~ cut) %>% 
  gf_labs(title = "Column Plot needs pre-counted data")


```

Note also that `gf_bar/geom_bar` takes only ONE variable (for the x-axis), whereas `gf_col/geom_col` needs both X and Y variables since it simply plots columns. 

Both are useful!

:::

::: callout-note
### And we can plot Proportions and Percentages too!
Also check out `gf_props` and `gf_percents` ! These are also very useful `ggformula` functions!

```{r}
#| layout-ncol: 2
#| results: hold

## Set graph theme
theme_set(new = theme_custom())
##

gf_props(~ substance,
  data = mosaicData::HELPrct, fill = ~ sex,
  position = "dodge"
) %>%
  gf_labs(title = "Plotting Proportions using gf_props")
###
gf_percents(~ substance,
  data = mosaicData::HELPrct, fill = ~ sex,
  position = "dodge"
)%>%
  gf_labs(title = "Plotting Percentages using gf_percents")
```


:::
### {{< iconify mdi chart-bell-curve >}} Plotting Densities

You might imagine a density chart as a histogram where the buckets are
infinitesimally small, i.e. zero width. This may seem counter-intuitive,
but densities have their uses in spotting the ranges in the data where
there are more frequent values. In this, they serve a similar purpose as
do histograms, but may offer insights not readily apparent with
histograms, especially with default bucket widths.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}


### Using ggformula

```{r}
#| label: density-charts-ggformula
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##


gf_density(~ price, data = diamonds) %>%
  gf_labs(title = "Plot A: Diamond Prices",caption = "ggformula")

###
diamonds %>% gf_density(~ price, 
                          fill = ~ cut, 
                          color = ~ cut,
                          alpha = 0.3) %>%
  gf_refine(scale_color_viridis_d(option = "magma",
                                  aesthetics = c("colour", "fill"))) %>%
  gf_labs(title = "Plot B: Prices by Cut",caption = "ggformula")

###
diamonds %>% gf_density(~ price,
                          fill = ~ cut) %>%
  gf_facet_wrap(vars(cut)) %>%
  gf_labs(title = "Plot C: Prices by Filled and Facetted by Cut",caption = "ggformula") 

###
diamonds %>% gf_density(~ price,
                          fill = ~ cut, 
                        color = "black") %>% 
  gf_facet_wrap(vars(cut), scales = "free_y", nrow = 2) %>%
  gf_labs(title = "Plot D: Prices Filled and Facetted by Cut", 
          subtitle = "Free y-scale", caption = "ggformula") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1)))


```

### Using ggplot

```{r}
#| label: density-charts-ggplot
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

diamonds %>% ggplot() + 
  geom_density(aes(price)) +
  labs(title = "Plot A: Diamond Prices",caption = "ggplot")

###
diamonds %>% ggplot() + 
  geom_density(aes(price, 
                   fill = cut, 
                   color = cut),
                   alpha = 0.3) +
  scale_color_viridis_d(option = "magma",
                        aesthetics = c("colour", "fill")) + 
  labs(title = "Plot B: Prices by Cut",caption = "ggplot")

###
diamonds %>% ggplot() + 
  geom_density(aes(price,
                   fill = cut)) + 
  facet_wrap(vars(cut)) + 
  labs(title = "Plot C: Prices by Filled and Facetted by Cut",
      caption = "ggplot") 

###
diamonds %>% ggplot() + 
  geom_density(aes(price,
                   fill = cut), 
                   color = "black") + 
  facet_wrap(vars(cut), scales = "free_y", nrow = 2) + 
  labs(title = "Plot D: Prices Filled and Facetted by Cut", 
          subtitle = "Free y-scale", caption = "ggplot") + 
  theme(axis.text.x = element_text(angle = 45,hjust = 1))


```



### {{< iconify noto-v1 spider-web >}} web-r
```{webr-r}
#| label: density-charts-ggformula-webr

gf_density(~ price, data = diamonds) %>%
  gf_labs(title = "Plot A: Diamond Prices",caption = "ggformula")
```

```{webr-r}
diamonds %>% gf_density(~ price, 
                          fill = ~ cut, 
                          color = ~ cut,
                          alpha = 0.3) %>%
  gf_refine(scale_color_viridis_d(option = "magma",
                                  aesthetics = c("colour", "fill"))) %>%
  gf_labs(title = "Plot B: Prices by Cut",caption = "ggformula")

```

```{webr-r}
diamonds %>% gf_density(~ price,
                          fill = ~ cut) %>%
  gf_facet_wrap(vars(cut)) %>%
  gf_labs(title = "Plot C: Prices by Filled and Facetted by Cut",caption = "ggformula") 

```

```{webr-r}
diamonds %>% gf_density(~ price,
                          fill = ~ cut, 
                        color = "black") %>% 
  gf_facet_wrap(vars(cut), scales = "free_y", nrow = 2) %>%
  gf_labs(title = "Plot D: Prices Filled and Facetted by Cut", 
          subtitle = "Free y-scale", caption = "ggformula") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1)))


```

```{webr-r}
#| label: density-charts-ggplot-webr

diamonds %>% ggplot() + 
  geom_density(aes(price)) +
  labs(title = "Plot A: Diamond Prices",caption = "ggplot")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_density(aes(price, 
                   fill = cut, 
                   color = cut),
                   alpha = 0.3) +
  scale_color_viridis_d(option = "magma",
                        aesthetics = c("colour", "fill")) + 
  labs(title = "Plot B: Prices by Cut",caption = "ggplot")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_density(aes(price,
                   fill = cut)) + 
  facet_wrap(vars(cut)) + 
  labs(title = "Plot C: Prices by Filled and Facetted by Cut",
      caption = "ggplot") 

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_density(aes(price,
                   fill = cut), 
                   color = "black") + 
  facet_wrap(vars(cut), scales = "free_y", nrow = 2) + 
  labs(title = "Plot D: Prices Filled and Facetted by Cut", 
          subtitle = "Free y-scale", caption = "ggplot") + 
  theme(axis.text.x = element_text(angle = 45,hjust = 1))


```
:::

::: callout-note
### Business Insights from `diamond` Densities

Pretty much similar conclusions as with histograms. Although densities
may not be used much in business contexts, they are *better* than
histograms when *comparing multiple distributions*! So you should use
thems!
:::

### {{< iconify carbon box-plot >}} Box Plots

Most plots do some internal calculations before creating the plots, such
as "counts" in bar charts, and also "buckets + counts" in histograms.

With boxplots, the *values* of a Quant variable are ranked in increasing
order of magnitude. The `median` and the `interquartile range` are also
calculated, and so are the `outliers`. A typical box plot looks like
this:

```{r}
#| label: boxplot MKdesc
#| echo: false
set.seed(2020)
MKdescr::illustrate.boxplot(rnorm(50, mean = 3, sd = 2))

```

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}


### Using ggformula

```{r}
#| label: Boxplots-ggformula
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

gf_boxplot(price ~ "All Diamonds", data = diamonds) %>% 
  gf_labs(title = "Plot A: Boxplot for Diamond Prices")

###
diamonds %>% 
  gf_boxplot(price ~ cut) %>% 
  gf_labs(title = "Plot B: Price by Cut")

###
diamonds %>% 
  gf_boxplot(price ~ cut, 
             fill = ~ cut, 
             color = ~ cut,
             alpha = 0.3) %>% 
  gf_labs(title = "Plot C: Price by Cut")

###
diamonds %>% 
  gf_boxplot(price ~ cut, 
             fill = ~ cut, 
             colour = ~ cut,             
             alpha = 0.3) %>% 
  gf_facet_wrap(vars(clarity)) %>%
  gf_labs(title = "Plot D: Price by Cut facetted by Clarity") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1)))

```

### Using ggplot

```{r}
#| label: Boxplots-ggplots
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

diamonds %>% ggplot() + 
  geom_boxplot(aes(y = price)) + # note: y, not x
  labs(title = "Plot A: Boxplot for Diamond Prices")

###
diamonds %>% ggplot() + 
  geom_boxplot(aes(cut, price)) + 
  labs(title = "Plot B: Price by Cut")

###
diamonds %>% ggplot() + 
  geom_boxplot(aes(cut, 
                   price, 
                   color = cut, fill = cut), alpha = 0.4) +
  labs(title = "Plot C: Price by Cut")

###
diamonds %>% ggplot() + 
  geom_boxplot(aes(cut, 
                   price, 
                   color = cut, fill = cut), alpha = 0.4)  +  
  facet_wrap(vars(clarity)) +
  labs(title = "Plot D: Price by Cut facetted by Clarity") +
  theme(axis.text.x = element_text(angle = 45,hjust = 1))

```


### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: Boxplots-ggformula-webr

gf_boxplot(price ~ ., data = diamonds) %>% 
  gf_labs(title = "Plot A: Boxplot for Diamond Prices")

```

```{webr-r}
diamonds %>% 
  gf_boxplot(price ~ cut) %>% 
  gf_labs(title = "Plot B: Price by Cut")

```

```{webr-r}
diamonds %>% 
  gf_boxplot(price ~ cut, 
             fill = ~ cut, 
             color = ~ cut,
             alpha = 0.3) %>% 
  gf_labs(title = "Plot C: Price by Cut")

```

```{webr-r}
diamonds %>% 
  gf_boxplot(price ~ cut, 
             fill = ~ cut, 
             colour = ~ cut,             
             alpha = 0.3) %>% 
  gf_facet_wrap(vars(clarity)) %>%
  gf_labs(title = "Plot D: Price by Cut facetted by Clarity") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1)))

```

```{webr-r}
#| label: Boxplots-ggplots-webr
#| layout-ncol: 2
diamonds %>% ggplot() + 
  geom_boxplot(aes(y = price)) + # note: y, not x
  labs(title = "Plot A: Boxplot for Diamond Prices")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_boxplot(aes(cut, price)) + 
  labs(title = "Plot B: Price by Cut")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_boxplot(aes(cut, 
                   price, 
                   color = cut, fill = cut), alpha = 0.4) +
  labs(title = "Plot C: Price by Cut")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_boxplot(aes(cut, 
                   price, 
                   color = cut, fill = cut), alpha = 0.4)  +  
  facet_wrap(vars(clarity)) +
  labs(title = "Plot D: Price by Cut facetted by Clarity") +
  theme(axis.text.x = element_text(angle = 45,hjust = 1))

```

:::

::: callout-note
### Business Insights from Boxplots

-   Plot A shows the presence of quite some high-end outliers; the
    median `price` is USD2500.
-   When broken up by Qual variable `cut` we see that the median mileage
    for different drive trains are slightly different...but not steadily
    increasing, on the contrary the median price drops for `Good`,
    `VeryGood` cuts, increases for `Premium` but stragely again drops
    for `Ideal` cuts.
-   This could again mean that `cut` alone does not determine diamond
    prices...
-   Similar trends with Plot D showing facetted plots
:::

### {{< iconify streamline nature-ecology-rainbow-arch-rain-colorful-rainbow-curve-half-circle >}} Ridge Plots

Sometimes we may wish to show the distribution/density of a Quant
variable, against several *levels* of a Qual variable. For instance, the
prices of different items of furniture, based on the furniture "style"
variable. Or the `sales` of a particular line of products, across
different shops or cities. We did this with both histograms and
densities, by colouring based on a Qual variable, and by facetting using
a Qual variable. There is a third way, using what is called a *ridge 
plot*. `ggformula` support this plot by importing/depending upon the `ggridges` package; however, `ggplot` itself appears to not have this capability. 

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### Using ggformula

```{r}
#| label: more-charts
#| out-width: "80%"
#| fig-align: "center"

## Set graph theme
theme_set(new = theme_custom())
##


gf_density_ridges(drv ~ hwy, fill = ~ drv, 
                  alpha = 0.3, 
                  rel_min_height = 0.005, data = mpg) %>% 
  gf_refine(scale_y_discrete(expand = c(0.01, 0)),
            scale_x_continuous(expand = c(0.01, 0))) %>% 
  gf_labs(title = "Ridge Plot")

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: more-charts-webr

gf_density_ridges(drv ~ hwy, fill = ~ drv, 
                  alpha = 0.3, 
                  rel_min_height = 0.005, data = mpg) %>% 
  gf_refine(scale_y_discrete(expand = c(0.01, 0)),
            scale_x_continuous(expand = c(0.01, 0))) %>% 
  gf_labs(title = "Ridge Plot")


```


:::



::: callout-note
### Business Insights from `mpg` Ridge Plots

This is another way of visualizing multiple distributions, of a Quant
variable at different levels of a Qual variable. We see that the
distribution of `hwy` mileage varies substantially with `drv` type.
:::

### {{< iconify carbon chart-violin-plot >}} Violin Plots

Often one needs to view **multiple densities** at the same time. Ridge
plots of course give us one option, where we get densities of a *Quant*
variable split by a *Qual* variable. Another option is to generate a
density plot facetted into *small multiples* using a *Qual* variable.

Yet another plot that allows comparison of multiple densities side by
side is a **violin plot**. The violin plot combines the aspects of a
*boxplot*(ranking of values, median, quantiles...) with a superimposed
*density* plot. This allows us to look at medians, means, densities, and
quantiles of a *Quant* variable with respect to another *Qual* variable.
Let us see what this looks like!

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### Using ggformula

```{r}
#| label: Violin plots with ggformula
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##


gf_violin(price ~ "All Diamonds", data = diamonds, 
          draw_quantiles = c(0,.25,.50,.75)) %>%
  gf_labs(title = "Plot A: Violin plot for Diamond Prices")

###
diamonds %>% 
  gf_violin(price ~ cut,
            draw_quantiles = c(0,.25,.50,.75)) %>% 
  gf_labs(title = "Plot B: Price by Cut")

###
diamonds %>% 
  gf_violin(price ~ cut, 
             fill = ~ cut, 
             color = ~ cut,
             alpha = 0.3,
            draw_quantiles = c(0,.25,.50,.75)) %>% 
  gf_labs(title = "Plot C: Price by Cut")

###
diamonds %>% 
  gf_violin(price ~ cut, 
             fill = ~ cut, 
             colour = ~ cut,             
             alpha = 0.3,draw_quantiles = c(0,.25,.50,.75)) %>% 
  gf_facet_wrap(vars(clarity)) %>%
  gf_labs(title = "Plot D: Price by Cut facetted by Clarity") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1)))

```

### Using ggplot

```{r}
#| label: Violin plots with ggplot
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

diamonds %>% ggplot() + 
  geom_violin(aes(y = price, x = ""),
              draw_quantiles = c(0,.25,.50,.75)) + # note: y, not x
  labs(title = "Plot A: violin for Diamond Prices")

###
diamonds %>% ggplot() + 
  geom_violin(aes(cut, price),
              draw_quantiles = c(0,.25,.50,.75)) + 
  labs(title = "Plot B: Price by Cut")

###
diamonds %>% ggplot() + 
  geom_violin(aes(cut, price, 
                  color = cut, fill = cut),
              draw_quantiles = c(0,.25,.50,.75),
              alpha = 0.4) +
  labs(title = "Plot C: Price by Cut")

###
diamonds %>% ggplot() + 
  geom_violin(aes(cut, 
                   price, 
                   color = cut, fill = cut), 
              draw_quantiles = c(0,.25,.50,.75),
              alpha = 0.4)  +  
  facet_wrap(vars(clarity)) +
  labs(title = "Plot D: Price by Cut facetted by Clarity") +
  theme(axis.text.x = element_text(angle = 45,hjust = 1))

```


### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: Violin plots with ggformula webr
#| collapse: true

gf_violin(price ~ "", data = diamonds, 
          draw_quantiles = c(0,.25,.50,.75)) %>%
  gf_labs(title = "Plot A: Violin plot for Diamond Prices")

```

```{webr-r}
diamonds %>% 
  gf_violin(price ~ cut,
            draw_quantiles = c(0,.25,.50,.75)) %>% 
  gf_labs(title = "Plot B: Price by Cut")

```

```{webr-r}
diamonds %>% 
  gf_violin(price ~ cut, 
             fill = ~ cut, 
             color = ~ cut,
             alpha = 0.3,
            draw_quantiles = c(0,.25,.50,.75)) %>% 
  gf_labs(title = "Plot C: Price by Cut")

```

```{webr-r}
diamonds %>% 
  gf_violin(price ~ cut, 
             fill = ~ cut, 
             colour = ~ cut,             
             alpha = 0.3,draw_quantiles = c(0,.25,.50,.75)) %>% 
  gf_facet_wrap(vars(clarity)) %>%
  gf_labs(title = "Plot D: Price by Cut facetted by Clarity") %>%
  gf_theme(theme(axis.text.x = element_text(angle = 45,hjust = 1)))

```

```{webr-r}
#| label: Violin plots with ggplot webr
#| layout-ncol: 2
#| collapse: true
diamonds %>% ggplot() + 
  geom_violin(aes(y = price, x = ""),
              draw_quantiles = c(0,.25,.50,.75)) + # note: y, not x
  labs(title = "Plot A: violin for Diamond Prices")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_violin(aes(cut, price),
              draw_quantiles = c(0,.25,.50,.75)) + 
  labs(title = "Plot B: Price by Cut")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_violin(aes(cut, price, 
                  color = cut, fill = cut),
              draw_quantiles = c(0,.25,.50,.75),
              alpha = 0.4) +
  labs(title = "Plot C: Price by Cut")

```

```{webr-r}
diamonds %>% ggplot() + 
  geom_violin(aes(cut, 
                   price, 
                   color = cut, fill = cut), 
              draw_quantiles = c(0,.25,.50,.75),
              alpha = 0.4)  +  
  facet_wrap(vars(clarity)) +
  labs(title = "Plot D: Price by Cut facetted by Clarity") +
  theme(axis.text.x = element_text(angle = 45,hjust = 1))

```

:::

::: callout-note
### Business Insights from `diamond` Violin Plots

The distribution for price is clearly *long-tailed* (skewed). The
distributions also vary considerably based on both `cut` and `clarity`.
These *Qual* variables clearly have a large effect on the prices of
individual diamonds.
:::


## {{< iconify grommet-icons test >}} Case Study-2: race dataset

### {{< iconify mdi database-import-outline >}} Import data

The data come from the
[TidyTuesday](https://github.com/rfordatascience/tidytuesday), project,
a weekly social learning project dedicated to gaining practical
experience with R and data science. In this case the TidyTuesday data
are based on [International Trail Running Association
(ITRA)](https://itra.run/Races/FindRaceResults) data but inspired by
Benjamin Nowak. We will use the [TidyTuesday data that are on
GitHub](https://github.com/rfordatascience/tidytuesday/tree/master/data/2021/2021-10-26).
Nowak's data are [also available on
GitHub](https://github.com/BjnNowak/UltraTrailRunning).

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R
```{r}
#| message: false
#| warning: false
race_df <- read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/race.csv")
rank_df <- read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/ultra_rankings.csv")

```

The data has automatically been read into the `webr` session, so you can continue on to the next code chunk!

```{webr-r}
#| context: setup
# Read the data
race_df <- read.csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/race.csv")
rank_df <- read.csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-26/ultra_rankings.csv")

```
:::


### {{< iconify file-icons influxdata >}} Examine the race Data

Let us look at the dataset using all our three methods:

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R

```{r}
#| label: glimpse-race-data
glimpse(race_df)
glimpse(rank_df)

```

```{r}
#| label: glimpse-race-data-1
skim(race_df)

```

```{r}
#| label: glimpse-race-data-2
skim(rank_df)

```

```{r}
#| label: inspect-race
# inspect(race_df) # does not work with hms and difftime variables
inspect(rank_df)

```


### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
#| label: glimpse-race-data-webr-1
glimpse(race_df)
glimpse(rank_df)

```

```{webr-r}
#| label: glimpse-race-data-webr-2
skim(race_df)
```

```{webr-r}
#| label: glimpse-race-data-webr-3
skim(rank_df)
```

```{webr-r}
#| label: inspect-race-webr
# inspect(race_df) # does not work with hms and difftime variables
inspect(rank_df)

```



:::



::: callout-note
### Business Insights from `race` data

-   We have two datasets, one for races (`race_df`) and one for the
    ranking of athletes (`rank_df`).
-   There is atleast one common column between the two, the
    `race_year_id` variable.
-   Overall, there are *Qualitative* variables such as `country`,
    `city`,`gender`, and `participation`. This last variables seems
    badly coded, with entries showing `solo` and `Solo`.
-   *Quantitative variables* are `rank`, `time`,`time_in_seconds`, `age`
    from `rank_df`; and `distance`, `elevation_gain`,
    `elevation_loss`,`particants`, and `aid_stations` from `race_df`.
-   We have 1207 races and over 130K participants! But some races do
    show *zero* participants!! Is that an error in data entry?
:::


### {{< iconify fluent-mdl2 explore-data >}} EDA with `race` datasets

::: callout-note

### Question #1
Which countries host the maximum number of races? Which
countries send the maximum number of participants??

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R

```{r}
race_df %>% count(country) %>% arrange(desc(n))
rank_df %>% count(nationality) %>% arrange(desc(n))

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
race_df %>% count(country) %>% arrange(desc(n))
rank_df %>% count(nationality) %>% arrange(desc(n))

```

:::

The top three locations for races were the USA, UK, and France. These
are also the countries that send the maximum number of participants,
naturally!
:::

::: callout-note
### Question #2
Which countries have the maximum number of winners (top 3
ranks)?

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R

```{r}
rank_df %>% 
  filter(rank %in% c(1,2,3)) %>%
  count(nationality) %>% arrange(desc(n))

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}
rank_df %>% 
  filter(rank %in% c(1,2,3)) %>%
  count(nationality) %>% arrange(desc(n))

```

:::

1240 Participants from the USA have been top 3 finishers. Across *all*
races...

:::


::: callout-note
### Question #3
Which countries have had the most top-3 finishes in the
**longest** distance race?

Here we see we have ranks in one dataset, and race details in another!
How do we do this now? We have to **join** the two data frames into one
data frame, using a *common variable* that uniquely identifies
observations in **both** datasets.

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R

```{r}
#| layout-nrow: 2

longest_races <- race_df %>%
  slice_max(n = 5, order_by = distance) # Longest distance races
longest_races

longest_races %>%
  left_join(., rank_df, by  = "race_year_id") %>% # total participants in longest 4 races
  filter(rank %in% c(1:10)) %>% # Top 10 ranks
  count(nationality) %>% arrange(desc(n))

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}

longest_races <- race_df %>%
  slice_max(n = 5, order_by = distance) # Longest distance races
longest_races

```

```{webr-r}

longest_races %>%
  left_join(., rank_df, by  = "race_year_id") %>% # total participants in longest 4 races
  filter(rank %in% c(1:10)) %>% # Top 10 ranks
  count(nationality) %>% arrange(desc(n))

```

:::


Wow....France has one the top 10 positions 26 times in the longest
races... which take place in France, Thailand, Chad, Australia, and
Portugal. So although the USA has the greatest number of top 10
finishes, when it comes to the *longest* races, it is `r emoji::emoji("france")` *vive la France*!

:::


::: callout-note
### Question #4
What is the distribution of the finishing times, across all
races and all ranks?

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R
```{r}

## Set graph theme
theme_set(new = theme_custom())
##

rank_df %>%
  gf_histogram(~ time_in_seconds, bins = 75) %>%
  gf_labs(title = "Histogram of Race Times")

```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}

rank_df %>%
  gf_histogram(~ time_in_seconds, bins = 75)  %>%
  gf_labs(title = "Histogram of Race Times")

```
:::

So the distribution is (very) roughly bell-shaped, spread over a 2X
range. And some people may have dropped out of the race very early and
hence we have a small bump close to *zero* time! The histogram shows
three bumps...at least one reason is that the distances to be covered
are not the same...but could there be other reasons? Like
`altitude_gained` for example?
:::


::: callout-note
### Question #5
What is the distribution of race distances?

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R
```{r}

## Set graph theme
theme_set(new = theme_custom())
##

race_df %>%
  gf_histogram(~ distance, bins =  50) %>%
  gf_labs(title = "Histogram of Race Distances")

```

Hmm...a closely clumped set of race distances, with some entries in
between \[0-150\], but some are zero? Which are these?

```{r}
race_df %>%
  filter(distance == 0)
```

### {{< iconify noto-v1 spider-web >}} web-r

```{webr-r}

race_df %>%
  gf_histogram(~ distance, bins =  50) %>%
  gf_labs(title = "Histogram of Race Distances")

```

Hmm...a closely clumped set of race distances, with some entries in
between \[0-150\], but some are zero? Which are these?

```{webr-r}

race_df %>%
  filter(distance == 0)

```
:::

Curious...some of these zero-distance races have had participants too!
Perhaps these were cancelled events...all of them are stated to be
`100 mile` events...

:::



::: callout-note
### Question #6
For all races that have a distance around 150, what is the
distribution of finishing times? Can these be split/facetted using
`start_time` of the race (i.e. morning / evening) ?

::: {.panel-tabset .nav-pills style="background: whitesmoke;"}

### {{< iconify la r-project >}} R

Let's make a count of start times:

```{r}

race_times <- race_df %>%
  count(start_time) %>% arrange(desc(n))
race_times

```

Let's convert `start_time` into a `factor` with levels:
early_morning(0200:0600), late_morning(0600:1000), midday(1000:1400),
afternoon(1400: 1800), evening(1800:2200), and night(2200:0200)

```{r}
#| label: Slicing_time_to_Qual
# Demo purposes only!

## Set graph theme
theme_set(new = theme_custom())
##

race_start_factor <- race_df %>%
  mutate(
    start_day_time =
      case_when(
        start_time > hms("02:00:00") &
          start_time <= hms("06:00:00") ~ "early_morning",
        
        start_time > hms("06:00:01") &
          start_time <= hms("10:00:00") ~ "late_morning",
        
        start_time > hms("10:00:01") &
          start_time <= hms("14:00:00") ~ "mid_day",
        
        start_time > hms("14:00:01") &
          start_time <= hms("18:00:00") ~ "afternoon",
        
        start_time > hms("18:00:01") &
          start_time <= hms("22:00:00") ~ "evening",
        
        start_time > hms("22:00:01") &
          start_time <= hms("23:59:59") ~ "night",
        
        start_time >= hms("00:00:00") &
          start_time <= hms("02:00:00") ~ "postmidnight",
        
        .default =  "other"
      )
  ) %>%
  mutate(start_day_time = 
           as_factor(start_day_time) %>%
           fct_collapse(.f = ., 
               night = c("night", "postmidnight")))
##
# Join with rank_df
race_start_factor %>%
  left_join(rank_df, by = "race_year_id") %>%
  drop_na(time_in_seconds) %>%
  gf_histogram(
    ~ time_in_seconds,
    bins = 75,
    fill = ~ start_day_time,
    color = ~ start_day_time,
    alpha = 0.5
  ) %>%
  gf_facet_wrap(vars(start_day_time), ncol = 2, scales = "free_y") %>%
  gf_labs(title = "Race Times by Start-Time")

```

### {{< iconify noto-v1 spider-web >}} web-r

Let's make a count of start times:

```{webr-r}

race_times <- race_df %>%
  count(start_time) %>% arrange(desc(n))
race_times

```

Let's convert `start_time` into a `factor` with levels:
early_morning(0200:0600), late_morning(0600:1000), midday(1000:1400),
afternoon(1400: 1800), evening(1800:2200), and night(2200:0200)

```{webr-r}
#| label: Slicing_time_to_Qual
# Demo purposes only!

race_start_factor <- race_df %>%
  mutate(
    start_day_time =
      case_when(
        start_time > hms("02:00:00") &
          start_time <= hms("06:00:00") ~ "early_morning",
        
        start_time > hms("06:00:00") &
          start_time <= hms("10:00:00") ~ "late_morning",
        
        start_time > hms("10:00:00") &
          start_time <= hms("14:00:00") ~ "mid_day",
        
        start_time > hms("14:00:00") &
          start_time <= hms("18:00:00") ~ "afternoon",
        
        start_time > hms("18:00:00") &
          start_time <= hms("22:00:00") ~ "evening",
        
        start_time > hms("22:00:00") &
          start_time <= hms("23:59:59") ~ "night",
        
        start_time >= hms("00:00:0") &
          start_time <= hms("02:00:00") ~ "postmidnight",
        
        .default =  "other"
      )
  ) %>%
  mutate(start_day_time = 
           as_factor(start_day_time) %>%
           fct_collapse(.f = ., 
               night = c("night", "postmidnight")))
```

```{webr-r}
# Join with rank_df
race_start_factor %>%
  left_join(rank_df, by = "race_year_id") %>%
  drop_na(time_in_seconds) %>%
  gf_histogram(
    ~ time_in_seconds,
    bins = 75,
    fill = ~ start_day_time,
    color = ~ start_day_time,
    alpha = 0.5
  ) %>%
  gf_facet_wrap(vars(start_day_time), ncol = 2, scales = "free_y")%>%
  gf_labs(title = "Race Times by Start-Time")

```

:::


We see that finish times tend to be longer for afternoon and evening
start races; these are lower for early morning and night time starts.
Mid-day starts show a curious double hump in finish times that should be
studied.
:::

## {{< iconify entypo new >}} Distributions and Densities in the Wild

Before we conclude, let us look at a real world dataset: populations of
countries. This dataset was taken from Kaggle
<https://www.kaggle.com/datasets/ulrikthygepedersen/populations>. Click
on the icon below to save the file into a *subfolder* called `data` in
your project folder:

{{< downloadthis data/populations.csv dname=populations label="Download the Populations data" icon=database-fill-down type=info class=data-button id=populations >}}

```{r}
#| layout-nrow: 2
pop <- read_csv("data/populations.csv")
pop
inspect(pop)

```

Let us plot densities/histograms for `value`:

```{r}
#| label: skewed-histogram
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

##
gf_histogram(~ value, data = pop, title = "Long Tailed Histogram") 
##
gf_density(~ value, data = pop, title = "Long Tailed Density")

```

These graphs convey very little to us: the data is very heavily skewed
to the right and much of the chart is empty. There are many countries
with small populations and a few countries with very large populations.
Such distributions are also called **"long tailed"** distributions. To
develop better insights with this data, we should transform the variable
concerned, using say a "log" transformation:

```{r}
#| label: skewed-density
#| layout-ncol: 2

## Set graph theme
theme_set(new = theme_custom())
##

gf_histogram(~ log10(value), data = pop, title = "Histogram with Log transformed x-variable") 
##
gf_density(~ log10(value), data = pop, title = "Density with Log transformed x-variable")

```

Be prepared to transform your data with `log` or `sqrt` transformations
when you see skewed distributions! Salaries, Instagram connections,
number of customers vs Companies, net worth / valuation of Companies,
extreme events on stock markets....all of these could have highly skewed
distributions. In such a case, the standard statistics of mean/median/sd
may not convey too much information.

## {{< iconify ph bell-simple-z-duotone >}} Z-scores

Often when we compute wish to compare distributions with different
values for means and standard deviations, we resort to a *scaling* of
the variables that are plotted in the respective distributions.

```{r}
#| label: z-scores
#| echo: false
#| layout-ncol: 2
library(TeachHist)

## Set graph theme
theme_set(new = theme_custom())
##

p1 <- TeachHistDens(Mean = 60, Sd = 5)
p3 <- TeachHistDens(Mean = 10, Sd = 5)
p2 <- TeachHistDens(Mean = 60, Sd = 15)
p4 <- TeachHistDens(Mean = 10, Sd = 15)


```

Although the densities all look the same, they are are quite different!
The x-axis in each case has *two scales*: one is the actual value of the
x-variable, and the other is the *z-score* which is calculated as:

$$
z_x = \frac{x - \mu_{x}}{\sigma_x}
$$

With similar distributions (i.e. normal distributions), we see that the
variation in density is the **same** at the same values of `z-score` for
each variable. However since the $\mu_i$ and $\sigma_i$ are different,
the *absolute* value of the `z-score` is different for each variable. In
the first plot (from the top left), $z = 1$ corresponds to an absolute
change of $5$ units; it is $15$ units in the plot directly below it.

Our comparisons are done easily when we compare differences in
probabilities at identical `z-scores`, or differences in `z-scores` at
identical probabilities.

## {{< iconify fluent-mdl2 decision-solid >}} Conclusion

-   Histograms, Frequency Distributions, and Box Plots are used for
    Quantitative data variables
-   Histograms "dwell upon" **counts**, **ranges**, **means** and
    **standard deviations**
-   Frequency Density plots "dwell upon" **probabilities** and
    **densities**
-   Box Plots "dwell upon" **medians** and **Quartiles**
-   Qualitative data variables can be plotted as **counts**, using Bar
    Charts, or using Heat Maps
-   Violin Plots help us to visualize multiple distributions at the same
    time, as when we split a *Quant* variable wrt to the *levels* of a
    *Qual* variable.
-   Ridge Plots are **density plots** used for describing one Quant and
    one Qual variable (by inherent splitting)
-   We can split all these plots on the basis of another Qualitative
    variable.(Ridge Plots are already split)
-   Long tailed distributions need care in visualization and in
    inference making!

## {{< iconify openmoji person >}} Your Turn

<a href="./files/data/qdd-data.zip">
<i class="fa-solid fa-database"></i> Datasets</a>

1.  Click on the Dataset Icon above, and unzip that archive. Try to make
    distribution plots with each of the three tools.
2.  A dataset from calmcode.io <https://calmcode.io/datasets.html>
3.  Old Faithful Data in R (Find it!)

`inspect` the dataset in each case and develop a set of Questions, that
can be answered by appropriate stat measures, or by using a chart to
show the distribution.

## {{< iconify ri slash-commands-2>}} R Commands Used Here{.hidden}

```{r}
#| label: used-these
#| echo: false
#| include: false
#| message: false
#| warning: false
library(usedthese)
used_here()

```

## {{< iconify ooui references-rtl >}} References

1. See the scrolly animation for a histogram at this website: *Exploring Histograms, an essay by Aran Lunzer and Amelia McNamara*
<https://tinlizzie.org/histograms/?s=09>\
1. Minimal R using
`mosaic`.<https://cran.r-project.org/web/packages/mosaic/vignettes/MinimalRgg.pdf>\
1. Sebastian Sauer, *Plotting multiple plots using purrr::map and ggplot* [](https://data-se.netlify.app/2021/02/06/plotting-multiple-plots-using-purrr-map-and-ggplot/)\

::: {#refs style="font-size: 60%;"}
###### {{< iconify lucide package-check >}} R Package Citations

```{r}
#| echo: false
#scan_packages()
cite_packages(
  output = "table",
  out.dir = ".",
  out.format = "html",
  pkgs = c("ggridges", "NHANES", "TeachHist",
           "TeachingDemos", "visualize")
) %>%
  knitr::kable(format = "simple")

```
:::
