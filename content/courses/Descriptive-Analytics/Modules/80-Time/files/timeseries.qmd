---
title: "Time Series in R"
author: "Arvind Venkatadri"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    toc: TRUE
    toc_float: TRUE
    toc_depth: 2
    df_print: paged
    number_sections: TRUE
    code_folding: hide
    code_download: TRUE
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
library(lubridate)  # Deal with dates

library(mosaic)

library(tsibble) # Create and manipulate Time Series in R
library(tsibbledata) # Tsibble Time Series Datasets
library(fable) # Modelling Time Series in R
library(fabletools)
library(feasts) # Feature Extraction and Statistics for Time Series.
library(timetk)  # Convert data frames to time series-specific objects
library(forecast)  # Make forecasts and decompose time series

# devtools::install_github("FinYang/tsdl")
library(tsdl) # Time Series Data Library from Rob Hyndman

# Don't install this if you are a student !! ;-D
library(downloadthis)

```

## Introduction

Any metric that is measured over regular time intervals forms a **time
series**. Analysis of Time Series is commercially important because of
industrial need and relevance, especially with respect to Forecasting
(Weather data, sports scores, population growth figures, stock prices,
demand, sales, supply...). In the graph shown below is the temperature
over times in two US cities:

<iframe width="100%" height="514" frameborder="0" src="https://observablehq.com/embed/f274bd3d517cf495?cells=LineChart">

</iframe>

A time series can be broken down to its components so as to
systematically understand, analyze, model and forecast it. We have to
begin by answering fundamental questions such as:

1.  What are the types of time series?\
2.  How to decompose it? How to extract a level, a trend, and seasonal
    components from a time series?\
3.  What is auto correlation etc.\
4.  What is a stationary time series?\
5.  And, how do you plot time series?

# Introduction to Time Series: Data Formats

There are multiple formats for time series data.

-   Tibble format: the simplest is of course the standard tibble/
    dataframe, with a `time` variable to indicate that the other
    variables vary with time.

-   The `ts` format: The `stats::ts()` function will convert a **numeric
    vector** into an R time series `ts` object.

-   The modern `tsibble` format: this is a new format for time series
    analysis, and is used by the [tidyverts](https://tidyverts.org) set
    of packages.

-   The base `ts` object is used by established packages `forecast`

-   The standard tibble object is used by `timetk` & `modeltime`

-   The special `tsibble` object ("time series tibble") is used by
    `fable`, `feasts` and others from the `tidyverts` set of packages

## Creating and Plotting Time Series

In this first example, we will use simple `ts` data first, and then do
another with `tsibble` format, and then a third example with a `tibble`
that we can plot as is and do more after conversion to `tsibble` format.

### `ts` format data

There are a few datasets in base R that are in `ts` format already.

```{r ts-data}

AirPassengers
str(AirPassengers)

```

This can be easily plotted using base R:

```{r}

plot(AirPassengers)

```

One can see that there is an upward *trend* and also *seasonal
variations* that also increase over time.

Let us take data that is "time oriented" but not in `ts` format: the
syntax of `ts()` is:

    Syntax:  objectName <- ts(data, start, end, frequency)

    where,

        `data`: represents the data vector
        `start`: represents the first observation in time series
        `end`: represents the last observation in time series
        `frequency`: represents number of observations per unit time. For 
        example 1=annual, 4=quarterly, 12=monthly, etc.

We will pick simple numerical vector data variable from `trees`:

```{r trees-ts}

trees

# Choosing the `height` variable
trees_ts <- ts(trees$Height, 
               frequency = 1, # No reason to believe otherwise
               start = 1980)  # Arbitrarily picked "1980" !
plot(trees_ts)

```

( Note that this example is just for demonstration: tree heights do not
decrease over time!!)

## `tsibble` data

The package `tsibbledata` contains several ready made `tsibble` format
data. Run `data(package = "tsibbledata")` to find out about these. Let
us try `PBS` which is a dataset containing Monthly Medicare prescription
data in Australia.

```{r PBS}

data("PBS")

```

This is a large dataset, with 1M observations, for 336 combinations of
`key` variables. Data appears to be *monthly*. Note that there is **more
than one** quantitative variable, which one would not be able to support
in the `ts` format.

There are multiple **Quantitative variables** ( `Scripts` and `Cost`).
The **Qualitative Variables** are described below. (Type `help("PBS")`
in your Console)

> The data is disaggregated using four keys:

> Concession: Concessional scripts are given to pensioners, unemployed,
> dependents, and other card holders\
> Type: Co-payments are made until an individual's script expenditure
> hits a threshold (\$290.00 for concession, \$1141.80 otherwise).
> Safety net subsidies are provided to individuals exceeding this
> amount.\
> ATC1: Anatomical Therapeutic Chemical index (level 1) ATC2: Anatomical
> Therapeutic Chemical index (level 2)

Let us simply plot `Cost` over time:

```{r PBS-Cost}

PBS %>% ggplot(aes(x = Month, y = Cost)) + 
  geom_point() + 
  geom_line()

```

This basic plot is quite messy. We ought to use `dplyr` to filter the
data using some combination of the Qualitative variables( 336
combinations!). Let us try that now:

```{r}

PBS %>% count(ATC1, ATC2, Concession, Type)

```

We have 336 combinations of **Qualitative** variables, each containing
204 observations: so let us filter for a few such combinations and plot:

```{r}

PBS %>% dplyr::filter(Concession == "General", 
                      ATC1 == "A",
                      ATC2 == "A10") %>% 
  ggplot(aes(x = Month, y = Cost, colour = Type)) + 
  geom_line() + 
  geom_point()

```

As can be seen, very different time patterns based on the two `Type`s of
payment methods. Strongly seasonal for both, with seasonal variation
increasing over the years, but there is an upward *trend* with the
Co-payments method of payment.

## `tibble` data

Let us read and inspect in the US births data from 2000 to 2014.
Download this data by clicking on the icon below, and saving the
downloaded file in a sub-folder called `data` inside your project:

Read this data in:

```{r read-in-data,echo=FALSE,message=FALSE}

births_2000_2014 <- read_csv("../data/US_births_2000-2014_SSA.csv")

# # This data goes up to 2003, but the previous data starts at 2000, so we'll
# # remove 2000-2003 from here
# births_1994_1999 <- read_csv("data/US_births_1994-2003_CDC_NCHS.csv") %>% 
#   filter(year < 2000)

glimpse(births_2000_2014)

```

So there are several numerical variables for `year`, `month`, and
`day_of_month`, `day_of_week`, and of course the `births` on a daily
basis. We will create a `date` column with these separate ones above,
and then plot the births, say for the month of March, in each year:

```{r, echo=FALSE}

births_tsibble <- births_2000_2014 %>% 
  mutate(date = lubridate::make_date(year = year,
                                     month = month,
                                     day = date_of_month)) %>%
  
  # drop year month day since we have date
  select(date, births, date_of_month,day_of_week) %>% 
  tsibble::as_tsibble(index = date # Time Variable
                      )

births_tsibble

births_tsibble %>%
  tsibble::index_by(month_index = ~ yearmonth(.)) %>% 
  # Grouping by month_index
  # NOT THE SAME AS `group_by(month)` !!!
  # if we had kept the original `month` variable !!!
  
  
  # Absolutely need this to take time averages
  summarise(mean_births = mean(births, na.rm = TRUE)) %>% 
  
  ggplot(., aes(x = month_index, y = mean_births)) + 
  geom_point() +
  geom_line()

```

Hmm...can we try to plot box plots over time (Candle-Stick Plots)? Over
month / quarter or year?

```{r,message=FALSE}

# Monthly box plots
births_tsibble %>%
  index_by(month_index = ~ yearmonth(.)) %>% # 180 months over 15 years
  # No need to summarise, since we want boxplots per year / month
  ggplot(., aes(y = births, x = date, 
                group =  month_index)) + # plot the groups
  
  geom_boxplot(aes(fill = month_index))      # 180 plots!!  
  
# Quarterly boxplots
births_tsibble %>%
  index_by(qrtr_index = ~ yearquarter(.)) %>% # 60 quarters over 15 years
  # No need to summarise, since we want boxplots per year / month
  ggplot(., aes(y = births, x = date, 
                group = qrtr_index)) +
  
  geom_boxplot(aes(fill = qrtr_index))        # 60 plots!!


# Yearwise boxplots
births_tsibble %>% 
  index_by(year_index = ~ lubridate::year(.)) %>% # 15 years, 15 groups
    # No need to summarise, since we want boxplots per year / month

  ggplot(., aes(y = births, 
                x = date, 
                group = year_index)) + # plot the groups
  
  geom_boxplot(aes(fill = year_index)) +           # 15 plots
  scale_fill_distiller(palette = "Spectral")

```

Although the graphs are very busy, they do reveal seasonality trends at
different periods.

## Seasons, Trends, Cycles, and Random Changes

> Trend A trend exists when there is a long-term increase or decrease in
> the data. It does not have to be linear. Sometimes we will refer to a
> trend as "changing direction", when it might go from an increasing
> trend to a decreasing trend.

> Seasonal A seasonal pattern occurs when a time series is affected by
> seasonal factors such as the time of the year or the day of the week.
> Seasonality is always of a fixed and known period. The monthly sales
> of drugs ( with the PBD data ) shows seasonality which is induced
> partly by the change in the cost of the drugs at the end of the
> calendar year.

> Cyclic A cycle occurs when the data exhibit rises and falls that are
> not of a fixed frequency. These fluctuations are usually due to
> economic conditions, and are often related to the "business cycle".
> The duration of these fluctuations is usually at least 2 years.

Let us try to find and plot these patterns in Time Series.

```{r,STL-model-yearly}

births_STL_yearly <- births_tsibble %>% 
  fabletools::model(STL(births ~ season(period = "year")))

fabletools::components(births_STL_yearly)
feasts::autoplot(components(births_STL_yearly))

```

How about a heatmap? We can cook up a categorical variable based on the
number of births (low, fine, high) and use that to create a heatmap:

```{r,echo=FALSE}


library(ggformula)

births_2000_2014 %>%  
  mutate(birthrate = case_when(births >=10000 ~ "high", births <= 8000 ~ "low", TRUE ~ "fine")) %>% 
  gf_tile(data = ., year ~ month, fill = ~ birthrate, color = "black") %>%
  
  gf_theme(scale_x_time(breaks = 1:12, labels = c("Jan", "Feb", "Mar","Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))) %>% 
  
  gf_theme(theme_classic())

```



## Case Study -1: Walmart Sales Dataset from `timetk`

Let us inspect what datasets are available in the package `timetk`. Type
`data(package = "timetk")` in your Console to see what datasets are
available.

Let us choose the Walmart Sales dataset. See here for more details:
[Walmart Recruiting - Store Sales Forecasting
\|Kaggle](https://www.kaggle.com/competitions/walmart-recruiting-store-sales-forecasting/data)

```{r}

data("walmart_sales_weekly")
walmart_sales_weekly
inspect(walmart_sales_weekly)
glimpse(walmart_sales_weekly)

# Try this in your Console
# help("walmart_sales_weekly")

```

The data is described as:

> A tibble: 9,743 x 3
>
> -   `id` Factor. Unique series identifier (4 total)
> -   `Store` Numeric. Store ID.
> -   `Dept` Numeric. Department ID.
> -   `Date` Date. Weekly timestamp.
> -   `Weekly_Sales` Numeric. Sales for the given department in the
>     given store.
> -   `IsHoliday` Logical. Whether the week is a "special" holiday for
>     the store.
> -   `Type` Character. Type identifier of the store.
> -   `Size` Numeric. Store square-footage
> -   `Temperature` Numeric. Average temperature in the region.
> -   `Fuel_Price` Numeric. Cost of fuel in the region.
> -   `MarkDown1, MarkDown2, MarkDown3, MarkDown4, MarkDown5` Numeric.
>     Anonymized data related to promotional markdowns that Walmart is
>     running. MarkDown data is only available after Nov 2011, and is
>     not available for all stores all the time. Any missing value is
>     marked with an NA.
> -   `CPI` Numeric. The consumer price index.
> -   `Unemployment` Numeric. The unemployment rate in the region.

Very cool to know that `mosaic::inspect()` identifies `date` variables
separately!

NOTE: 1. This is still a `data.frame`, with a time-oriented variable of
course, and not yet a time-series object. Note that this data frame has
the YMD columns repeated for each `Dept`. 2. The `Date` column has
repeated entries for each `Dept`! To deal with this repetition, we will
always need to split the `Weekly_Sales` by the `Dept` column before we
plot or analyze.

Since our sales are *weekly*, we will convert Date to `yearweek` format:

```{r}

walmart_time <- walmart_sales_weekly %>% 
  # mutate(Date = as.Date(Date)) %>% 
  as_tsibble(index = Date, # Time Variable
             key = Dept 
             
  #  Identifies unique "subject" who are measures
  #  All other variables such as Weekly_sales become "measured variable"
  #  Each observation should be uniquely identified by index and key

             )
walmart_time

```

### Basic Time Series Plots

The easiest way is to use `autoplot` from the `feasts` package. You may
need to specify the actual measured variable, if there is more than one
numerical column:

```{r feasts-basic-plot}

autoplot(walmart_time,.vars = Weekly_Sales)


```

`timetk` gives us *interactive plots* that may be more evocative than
the static plot above. The basic plot function with `timetk` is
`plot_time_series`. There are arguments for the date variable, the value
you want to plot, colours, groupings etc.

Let us explore this dataset using `timetk`, using our trusted method of
asking Questions:

**Q.1 How are the weekly sales different for each Department?**

There are `r walmart_sales_weekly %>%  distinct(Dept) %>% count()`
number of Departments. So we should be fine plotting them and also
**facetting** with them, as we will see in a bit:

```{r}

walmart_time %>%   timetk::plot_time_series(Date, Weekly_Sales,
                   .color_var = Dept, .legend_show = TRUE,
                   .title = "Walmart Sales Data by Department",
                   .smooth = FALSE)

```

**Q.2. What do the sales per Dept look like during the month of December
(Christmas time) in 2012? Show the individual Depts as facets.**

We can of course **zoom** into the interactive plot above, but if we
were to plot it anyway:

```{r filtering-by-time}

# Only include rows from  1 to December 31, 2011
# Data goes only up to Oct 2012

walmart_time %>% 
  # Each side of the time_formula is specified as the character 'YYYY-MM-DD HH:MM:SS',
  timetk::filter_by_time(.date_var = Date,
                         .start_date = "2011-12-01",
                         .end_date = "2011-12-31") %>%

  plot_time_series(.date_var = Date, 
                   .value = Weekly_Sales, 
                   .color_var = Dept, 
                   .facet_vars = Dept, 
                   .facet_ncol = 2,
                   .smooth = FALSE) # Only 4 points per graph

```

Clearly the "unfortunate"
[Dept#13](https://u.osu.edu/vanzandt/2019/04/12/is-13-really-that-unlucky/)
has seen something of a Christmas drop in sales, as has Dept#38 ! The
rest, all is well, it seems...

### Too much noise? How about some averaging?

**Q.3 How do we smooth out some of the variations in the time series to
be able to understand it better?**

Sometimes there is too much noise in the time series observations and we
want to take what is called a **rolling average**. For this we will use
the function `timetk::slidify` to create an averaging function of our
choice, and then apply it to the time series using regular
`dplyr::mutate`

```{r averaging-function}

# Let's take the average of Sales for each month in each Department.
# Our **function** will be named "rolling_avg_month": 

rolling_avg_month = slidify(.period = 4, # every 4 weeks
                            .f = mean, # The funtion to average
                            .align = "center", # Aligned with middle of month
                            .partial = TRUE) # TO catch any leftover half weeks
rolling_avg_month


```

OK, `slidify` creates a `function`! Let's apply it to the Walmart Sales
time series...

```{r averaging}

walmart_time %>% 
  # group_by(Dept) %>% 
  mutate(avg_monthly_sales = rolling_avg_month(Weekly_Sales)) %>% 
  # ungroup() %>% 
  timetk::plot_time_series(Date, avg_monthly_sales,.color_var = Dept, .smooth = FALSE)


```

Curves are smoother now. Need to check whether the `averaging` was done
on a per-`Dept` basis...should we have had a `group_by(Dept)` before the
averaging, and `ungroup()` before plotting? Try it !!

### Decomposing Time Series: Trends, Seasonal Patterns, and Cycles

Each data point ($Y_t$) at time $t$ in a Time Series can be expressed as
either a sum or a product of 4 components, namely, Seasonality($S_t$),
Trend($T_t$), Cyclic, and Error($e_t$) (a.k.a White Noise).

-   Trend: pattern exists when there is a long-term increase or decrease
    in the data.
-   Seasonal: pattern exists when a series is influenced by seasonal
    factors (e.g., the quarter of the year, the month, or day of the
    week).
-   Cyclic: pattern exists when data exhibit rises and falls that are
    not of fixed period (duration usually of at least 2 years).
-   Error or Noise: Random component

Decomposing **non-seasonal data**s means breaking it up into *trend* and
*irregular* components.To estimate the trend component of a non-seasonal
time series that can be described using an additive model, it is common
to use a **smoothing method**, such as calculating the *simple moving
average of the time series*.

`timetk` has the ability to achieve this: Let us plot the `trend`,
`seasonal`, `cyclic` and `irregular` aspects of `Weekly_Sales` for Dept
38:

```{r decompose-time-series}

walmart_time %>% 
  filter(Dept == "38") %>% 
  timetk::plot_stl_diagnostics(.date_var = Date, .value = Weekly_Sales)

```

We can do this for **all** `Dept` using `fable` and `fabletools`:

```{r Decomposing_trends}

walmart_decomposed <- 
  walmart_time %>% 
  
  # If we want to filter, we do it here
  # filter(Dept == "38") %>% 
  # 

fabletools::model(stl = STL(Weekly_Sales))

fabletools::components(walmart_decomposed)

autoplot(components((walmart_decomposed)))

```

## Case Study-2: Dataset from `nycflights13`

Let us try the flights dataset from the package `nycflights13`. Try
`data(package = "nycflights13")` in your Console.

We have the following datasets in`nycflights13`:

Data sets in package `nycflights13`:

-   `airlines` Airline names.
-   `airports` Airport metadata
-   `flights` Flights data
-   `planes` Plane metadata.
-   `weather` Hourly weather data

Let us analyze the `flights` data:

```{r}

data("flights", package = "nycflights13")
mosaic::inspect(flights)

```

We have *time-related* columns; Apart from `year, month, day` we have
`time_hour`; and time-event numerical data such as `arr_delay` (arrival
delay) and `dep_delay` (departure delay). We also have categorical data
such as `carrier, origin, dest`, `flight` and `tailnum` of the aircraft.
It is also a large dataset containing 330K entries. Enough to play
with!!

Let us replace the `NA`s in `arr_delay` and `dep_delay` with zeroes for
now, and convert it into a time-series object with `tsibble`:

```{r}

flights_delay_ts <- flights %>% 
  
  mutate(arr_delay = replace_na(arr_delay, 0), 
         dep_delay = replace_na(dep_delay, 0)) %>% 
  
  select(time_hour, arr_delay, dep_delay, carrier, origin, dest, flight, tailnum) %>% 
  tsibble::as_tsibble(index = time_hour, 
                      # All the remaining identify unique entries
                      # Along with index
                      # Many of these variables are common
                      # Need *all* to make unique entries!
                      key = c(carrier, origin, dest,flight, tailnum), 
                      validate = TRUE) # Making sure each entry is unique


flights_delay_ts


```

**Q.1. Plot the monthly average arrival delay by carrier**

```{r}

mean_arr_delays_by_carrier <- 
  flights_delay_ts %>%
  group_by(carrier) %>% 
  
  index_by(month = ~ yearmonth(.)) %>% 
  # index_by uses (year, yearquarter, yearmonth, yearweek, as.Date)
  # to create a new column to show the time-grouping
  # year / quarter / month/ week, or day...
  # which IS different from traditional dplyr
  
  summarise(mean_arr_delay = mean(arr_delay, na.rm = TRUE)
  )

mean_arr_delays_by_carrier

mean_arr_delays_by_carrier %>%
  timetk::plot_time_series(
    .date_var = month,
    .value = mean_arr_delay,
    .facet_vars = carrier,
    .smooth = FALSE,
    # .smooth_degree = 1,
    
    # keep .smooth off since it throws warnings if there are too few points
    # Like if we do quarterly or even yearly summaries
    # Use only for smaller values of .smooth_degree (0,1)
    #
    .facet_ncol = 4,
    .title = "Average Monthly Arrival Delays by Carrier"
  )


```

**Q.2. Plot a candlestick chart for total flight delays by month for
each carrier**

```{r}

flights_delay_ts %>% 
  mutate(total_delay = arr_delay + dep_delay) %>%
  timetk::plot_time_series_boxplot(
    .date_var = time_hour,
    .value = total_delay,
    .color_var = origin,
    .facet_vars = origin,
    .period = "month",
  # same warning again
    .smooth = FALSE
  )

```

**Q.2. Plot a heatmap chart for total flight delays by origin,
aggregated by month**

```{r}

avg_delays_month <- flights_delay_ts %>% 
  group_by(origin) %>% 
  mutate(total_delay = arr_delay + dep_delay) %>% 
  index_by(month = ~ yearmonth(.)) %>% 
  # index_by uses (year, yearquarter, yearmonth, yearweek, as.Date)
  # to create a new column to show the time-grouping
  # year / quarter / month/ week, or day...
  # which IS different from traditional dplyr
    summarise(mean_monthly_delay = mean(total_delay, na.rm = TRUE)
  )

avg_delays_month 
# three origins 12 months therefore 36 rows
# Tsibble index_by + summarise also gives us a  month` column 



ggformula::gf_tile(origin ~ month, fill = ~ mean_monthly_delay, 
                   color = "black", data = avg_delays_month,
                   title = "Mean Flight Delays from NY Airports in 2013") %>% 
  gf_theme(theme_classic()) %>% 
  gf_theme(scale_fill_viridis_c(option = "A")) %>% 
  
# "magma" (or "A") inferno" (or "B") "plasma" (or "C") 
# "viridis" (or "D") "cividis" (or "E") 
# "rocket" (or "F") "mako" (or "G") "turbo" (or "H")

  gf_theme(scale_x_time(breaks = 1:12, labels = month.abb))

```

# Conclusion

We can plot most of the common Time Series Plots with the help of the
**tidyverts** packages: ( `tsibble`, `feast`, `fable` and `fabletools`)
, along with `timetk` and `ggformula`.

There are other plot packages to investigate, such as
[dygraphs](https://rstudio.github.io/dygraphs/index.html)

Recall that we have used the `tsibble` format for the data. There are
other formats such as `ts`, `xts` and others which are meant for time
series analysis. But for our present purposes, we are able to do things
with the capabilities of `timetk`.

# References

1.  Rob J Hyndman and George Athanasopoulos, *Forecasting:
    Principles and Practice (3rd ed)*, Available Online
    <https://otexts.com/fpp3/>
