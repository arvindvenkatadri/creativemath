{
  "hash": "21855901201851e41a4639439e304451",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recreating Mondrian\"\nformat: html\n---\n\n####################################################################\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gsubfn)\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of symbols in rule\ns <- sample(15:26, 1) \n# Extract s symbols from c(\"F\", \"+\", \"-\") randomly\nv1 <- sample(c(\"F\", \"+\", \"-\"), size = s, replace = TRUE, prob = c(10,12,12))\n# Add 3 pairs of brackets\nv2 <- sample(\"[]\", 3, replace = TRUE) %>% str_extract_all(\"\\\\d*\\\\+|\\\\d*\\\\-|F|L|R|\\\\[|\\\\]|\\\\|\") %>% unlist\n# Where to insert brackets\nv3 <- sample(1:(s+1), size = length(v2)) %>% sort\n# Insert them correctly\nfor(i in 1:length(v3)){\n  c(v1[1:(v3[i] + i - 1)], v2[i], v1[(v3[i] + i - 1):length(v1)]) -> v1\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# All pictures start with the same axiom\naxiom <- \"F-F-F-F\"\n# Rule to substitute F, as generated previously\nrules <- list(\"F\"=paste(v1, collapse=\"\"))\n# Turning angle\nangle <- 90\n# How many times to apply the rule\ndepth <- sample(3:4,1)\n# Longitude (factor) of the segments\nds <- jitter(1)\n# Substitute axiom depth times\nfor (i in 1:depth) axiom <- gsubfn(\".\", rules, axiom)\n# Actions that will generate the drawing  \nactions <- str_extract_all(axiom, \"\\\\d*\\\\+|\\\\d*\\\\-|F|L|G|R|\\\\[|\\\\]|\\\\|\") %>% unlist\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# These vars store the current position, angle and longitude factor of the point\nx_current <- 0\ny_current <- 0\na_current <- 0\nd_current <- 0\n\n# To store point position, angle and longitude\nstatus <- tibble(x = x_current, \n                 y = y_current, \n                 alfa = a_current,\n                 depth = d_current)\n# To store segments  \nlines <- data.frame(x = numeric(), \n                    y = numeric(), \n                    xend = numeric(), \n                    yend = numeric())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# This loop reads actions and generates the drawing depending on the concrete action\n#   F -> draw forward\n#   + -> turn right\n#   - -> turn left\n#   [ -> save the current status of point\n#   ] -> restore the last current status of point and remove from stack\nfor (action in actions) \n{\n  if (action==\"F\") {\n    lines <- lines %>% add_row(x = x_current,\n                               y = y_current,\n                               xend = x_current + (ds^d_current) * cos(a_current * pi / 180),\n                               yend = y_current + (ds^d_current) * sin(a_current * pi / 180)) \n    x_current <- x_current + (ds^d_current) * cos(a_current * pi / 180)\n    y_current <- y_current + (ds^d_current) * sin(a_current * pi / 180)\n    d_current <- d_current + 1\n  }\n  if (action==\"+\") {\n    a_current <- a_current - angle\n  }\n  if (action==\"-\") {\n    a_current <- a_current + angle\n  }\n  if (action==\"[\") { \n    status <- status %>% add_row(x = x_current, \n                                 y = y_current, \n                                 alfa = a_current,\n                                 depth = d_current)\n  }\n  if (action==\"]\") {\n    x_current <- tail(status, 1) %>% pull(x)\n    y_current <- tail(status, 1) %>% pull(y)\n    a_current <- tail(status, 1) %>% pull(alfa)\n    d_current <- tail(status, 1) %>% pull(depth)\n    status <- head(status, -1)\n  }\n}\n\n  lines %>%\n    mutate(x = round(x, 1),\n           y = round(y, 1),\n           xend = round(xend, 1),\n           yend = round(yend, 1)) %>%\n    distinct(x, y, xend, yend) -> lines\n  \n  select(lines, x3 = x, y3 =y) %>%\n    bind_rows(select(lines, x3 = xend, y3 =yend)) %>%\n    distinct(x3, y3) -> points\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's find squares to fill inside the drawing\n# Since this operation maybe hard to compute, I divide points into \n# 10 pieces to process them separately\nn <- 10\n  \nsplit(points, rep(1:ceiling(nrow(points)/n), \n                  each = n, \n                  length.out = nrow(points))) -> points_divided\n  \n# Squares1: add X3, y3 to current segments and filter to find \n# right angles\n  lapply(points_divided, function(sub) {\n    sub %>% \n      crossing(lines) %>%\n      filter(x == x3 | y == y3 | xend == x3 | yend == y3) %>%\n      filter(x != x3 | y != y3 , xend != x3 | yend != y3) %>%\n      mutate(id = row_number())\n  }) %>% bind_rows() -> squares1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Squares2:  keep those squares where some of new sides exist in lines\nbind_rows(\n    squares1 %>%\n      inner_join(lines, c(\"x\" = \"x\", \n                          \"y\" = \"y\", \n                          \"x3\" = \"xend\", \n                          \"y3\" = \"yend\")),\n    squares1 %>%\n      inner_join(lines, c(\"xend\" = \"x\", \n                          \"yend\" = \"y\", \n                          \"x3\" = \"xend\", \n                          \"y3\" = \"yend\")),\n    squares1 %>%\n      inner_join(lines, c(\"x3\" = \"x\", \n                          \"y3\" = \"y\", \n                          \"x\" = \"xend\", \n                          \"y\" = \"yend\")),\n    squares1 %>%\n      inner_join(lines, c(\"x3\" = \"x\", \n                          \"y3\" = \"y\", \n                          \"xend\" = \"xend\", \n                          \"yend\" = \"yend\"))) %>%\n    distinct(x, y, xend, yend, x3, y3, id) -> squares2\n  \n# Remove those whose sides form a straight line\nsquares2 %>% \n    anti_join(squares2 %>% filter(x == xend, xend == x3),\n              by = c(\"x\", \"y\", \"xend\", \"yend\", \"x3\", \"y3\", \"id\")) -> squares2\n  \nsquares2 %>% \n    anti_join(squares2 %>% filter(y == yend, yend == y3),\n              by = c(\"x\", \"y\", \"xend\", \"yend\", \"x3\", \"y3\", \"id\")) -> squares2\n  \n# We leave squares2 prepared for geom_rect\nsquares2 %>%\n    mutate(xmax = pmax(x, xend, x3),\n           xmin = pmin(x, xend, x3),\n           ymax = pmax(y, yend, y3),\n           ymin = pmin(y, yend, y3)) %>%\n    mutate(A = (xmax - xmin) * (ymax - ymin) / 2) -> squares\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Piet mondrian's palette\ncolors <- c(\"#FEFFFA\",\"#000002\",\"#F60201\",\"#FDED01\", \"#1F7FC9\")\n\n# To remove very small squares I calculate quantiles from its area\nqnts <- quantile(squares$A, \n                   probs = seq(0, 1, 0.05), \n                   na.rm = FALSE,\n                   names = TRUE, \n                   type = 7)\n\n# Here comes the magic of ggplot\nggplot() +\n    geom_rect(aes(xmax = xmax,\n                  xmin = xmin,\n                  ymax = ymax,\n                  ymin = ymin,\n                  fill = id %% length(colors) %>% jitter(amount=.025)),\n              data = squares %>% filter(A >= qnts[1]), # remove small squares\n              lwd = 2,\n              color = \"white\") +\n    geom_segment(aes(x = x, y = y, xend = xend, yend = yend),\n                 data = lines,\n                 lwd = .65,\n                 lineend = \"square\",\n                 color = \"#000002\") +\n    scale_fill_gradientn(colors = colors) +\n    theme_void() +\n    theme(legend.position = \"none\") +\n    coord_equal() -> plot\nplot  \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=2100}\n:::\n\n```{.r .cell-code}\n# Calculate dimensions of the picture for ggsave\nwidth <- max(points$x3) - min(points$x3)\nheight <- max(points$y3) - min(points$y3)\n  \nwhmax <- 8\nif (width >= height) {\n  w <- whmax\n  h <- whmax * height / width \n} else {\n  h <- whmax\n    w <- whmax * width / height\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save the drawing with a random name\nname <- paste(sample(letters,6), collapse = \"\")\nggsave(paste0(\"./new/\",name,\".png\"), plot, width = w, height = h)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}